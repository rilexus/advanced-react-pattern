<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/advanced-react-pattern/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/advanced-react-pattern/_next/static/chunks/webpack-f9606f09ac75a39a.js" defer=""></script><script src="/advanced-react-pattern/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/advanced-react-pattern/_next/static/chunks/main-958c758f0e3a0160.js" defer=""></script><script src="/advanced-react-pattern/_next/static/chunks/pages/_app-86ba28c549340a29.js" defer=""></script><script src="/advanced-react-pattern/_next/static/chunks/170-d59642f47b4b233e.js" defer=""></script><script src="/advanced-react-pattern/_next/static/chunks/pages/UndoState-bba91b362e95f1f9.js" defer=""></script><script src="/advanced-react-pattern/_next/static/n796NygtBGS4-RVWA6qV3/_buildManifest.js" defer=""></script><script src="/advanced-react-pattern/_next/static/n796NygtBGS4-RVWA6qV3/_ssgManifest.js" defer=""></script><script src="/advanced-react-pattern/_next/static/n796NygtBGS4-RVWA6qV3/_middlewareManifest.js" defer=""></script><style data-styled="" data-styled-version="5.3.5">html{-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%;}/*!sc*/
body{font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;margin:0;padding:0;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;}/*!sc*/
figure{margin:0;}/*!sc*/
.hljs{background:#f6f6f6;border-radius:.5rem;padding:2rem 1rem 2rem 2rem;color:black;font-size:.95rem;line-height:1.25;}/*!sc*/
.xml .hljs-meta{color:#c0c0c0;}/*!sc*/
.hljs-comment,.hljs-quote{color:#007400;}/*!sc*/
.hljs-tag,.hljs-attribute,.hljs-keyword,.hljs-selector-tag,.hljs-literal,.hljs-name{color:#aa0d91;}/*!sc*/
.hljs-variable,.hljs-template-variable{color:#3F6E74;}/*!sc*/
.hljs-code,.hljs-string,.hljs-meta .hljs-string{color:#c41a16;}/*!sc*/
.hljs-regexp,.hljs-link{color:#0E0EFF;}/*!sc*/
.hljs-title,.hljs-symbol,.hljs-bullet,.hljs-number{color:#1c00cf;}/*!sc*/
.hljs-section,.hljs-meta{color:#643820;}/*!sc*/
.hljs-title.class_,.hljs-class .hljs-title,.hljs-type,.hljs-built_in,.hljs-params{color:#5c2699;}/*!sc*/
.hljs-attr{color:#836C28;}/*!sc*/
.hljs-subst{color:#000;}/*!sc*/
.hljs-formula{background-color:#eee;font-style:italic;}/*!sc*/
.hljs-addition{background-color:#baeeba;}/*!sc*/
.hljs-deletion{background-color:#ffc8bd;}/*!sc*/
.hljs-selector-id,.hljs-selector-class{color:#9b703f;}/*!sc*/
.hljs-doctag,.hljs-strong{font-weight:bold;}/*!sc*/
.hljs-emphasis{font-style:italic;}/*!sc*/
data-styled.g1[id="sc-global-eTUlez1"]{content:"sc-global-eTUlez1,"}/*!sc*/
.jfHJAM{margin-right:auto;margin-left:auto;padding-right:15px;padding-left:15px;width:100%;}/*!sc*/
@media screen and (max-width:575px){.jfHJAM{min-width:97vw;}}/*!sc*/
@media screen and (min-width:576px){.jfHJAM{max-width:1024px;}}/*!sc*/
data-styled.g2[id="Container__Styled-sc-zkefve-0"]{content:"jfHJAM,"}/*!sc*/
.fHFsLe{white-space:nowrap;line-height:1.5;}/*!sc*/
data-styled.g3[id="Li__Styled-sc-2pbekf-0"]{content:"fHFsLe,"}/*!sc*/
</style></head><body><div id="__next"><div class="Container__Styled-sc-zkefve-0 jfHJAM"><div style="display:flex;flex-direction:row"><div style="margin-right:1rem"><nav><ul style="padding-left:1rem"><li class="Li__Styled-sc-2pbekf-0 fHFsLe"><a href="/advanced-react-pattern">Home</a></li><li class="Li__Styled-sc-2pbekf-0 fHFsLe"><h4>Utils</h4><ul style="padding-left:1rem"><li class="Li__Styled-sc-2pbekf-0 fHFsLe"><a href="/advanced-react-pattern/Prefetch">Prefetched State</a></li><li class="Li__Styled-sc-2pbekf-0 fHFsLe"><a href="/advanced-react-pattern/StateSubscription">State Subscription</a></li></ul></li><li class="Li__Styled-sc-2pbekf-0 fHFsLe"><h4>Components</h4><ul style="padding-left:1rem"><li class="Li__Styled-sc-2pbekf-0 fHFsLe"><a href="/advanced-react-pattern/suspense">Suspense</a></li><li class="Li__Styled-sc-2pbekf-0 fHFsLe"><a href="/advanced-react-pattern/CompoundToggle">Compound Components</a></li><li class="Li__Styled-sc-2pbekf-0 fHFsLe"><a href="/advanced-react-pattern/StateReducer">State Reducer</a></li><li class="Li__Styled-sc-2pbekf-0 fHFsLe"><a href="/advanced-react-pattern/PropCollection">Props Collection</a></li><li class="Li__Styled-sc-2pbekf-0 fHFsLe"><a href="/advanced-react-pattern/RenderPropsToggle">Render Props</a></li><li class="Li__Styled-sc-2pbekf-0 fHFsLe"><a href="/advanced-react-pattern/Factory">Factory</a></li><li class="Li__Styled-sc-2pbekf-0 fHFsLe"><a href="/advanced-react-pattern/ControlProps">Control Props</a></li><li class="Li__Styled-sc-2pbekf-0 fHFsLe"><a href="/advanced-react-pattern/Decorator">Decorator</a></li></ul></li><li class="Li__Styled-sc-2pbekf-0 fHFsLe"><h4>Hooks</h4><ul style="padding-left:1rem"><li class="Li__Styled-sc-2pbekf-0 fHFsLe"><a href="/advanced-react-pattern/ReducerHook">Reducer Hook</a></li><li class="Li__Styled-sc-2pbekf-0 fHFsLe"><a href="/advanced-react-pattern/UndoState">Undo State</a></li><li class="Li__Styled-sc-2pbekf-0 fHFsLe"><a href="/advanced-react-pattern/ThunkReducer">Thunk Reducer</a></li><li class="Li__Styled-sc-2pbekf-0 fHFsLe"><a href="/advanced-react-pattern/FetchHook">Fetch Hook</a></li></ul></li></ul></nav></div><div><div><h1 style="font-size:2rem">Undo State</h1><p style="line-height:1.4;font-size:1.125rem;color:#1a1a1a">Very common requirements in some what complex web applications is the “undo“ functionality. The user wants to undo the recent changes made in the application by pressing a button. You&#x27;ll know this behaviour when you press “command-z“ on mac or “strg-z“ on windows.</p><p style="line-height:1.4;font-size:1.125rem;color:#1a1a1a">Example:</p><div><input placeholder="Type" type="text" value=""/><button disabled="">undo</button><button disabled="">redo</button><button>reset</button></div><p style="line-height:1.4;font-size:1.125rem;color:#1a1a1a">Translating this requirements in to react would means setting the current state of a component to the previous states.</p><p style="line-height:1.4;font-size:1.125rem;color:#1a1a1a">First we would need a component any state:</p><pre>const Component = () =&gt; {
  const [state, setState] = useState(&quot;&quot;);

  const handleChange = (e) =&gt; {
    setState(e.target.value);
  };

  return (
    &lt;div&gt;
      &lt;input type=&quot;text&quot; onChange={handleChange} value={state} /&gt;
    &lt;/div&gt;
  );
};</pre><p style="line-height:1.4;font-size:1.125rem;color:#1a1a1a">When we set a new state, We would need to keep track of all the previous states:</p><pre>const Component = () =&gt; {
  const [state, setState] = useState({
    current: &quot;&quot;,
    past: [],
  });

  const handleChange = (e) =&gt; {
    setState((oldState) =&gt; {
      const { value } = e.target;
      return {
        ...oldState,
        past: [...oldState.past, oldState.current],
        current: value,
      };
    });
  };

  return (
    &lt;div&gt;
      &lt;input type=&quot;text&quot; onChange={handleChange} value={state.current} /&gt;
    &lt;/div&gt;
  );
};</pre><p style="line-height:1.4;font-size:1.125rem;color:#1a1a1a">We save all the past states by adding the current value from the oldState to the past array and in the same time add the new value to the current.</p><pre>const Component = () =&gt; {
  const [state, setState] = useState({
    current: &quot;&quot;,
    past: [],
  });

  const handleChange = (e) =&gt; {
    setState((oldState) =&gt; {
      const { value } = e.target;
      return {
        ...oldState,
        past: [...oldState.past, oldState.current],
        current: value,
      };
    });
  };

  return (
    &lt;div&gt;
      &lt;input type=&quot;text&quot; onChange={handleChange} value={state.current} /&gt;
    &lt;/div&gt;
  );
};</pre><p style="line-height:1.4;font-size:1.125rem;color:#1a1a1a">Now to undo the state change, we would need to take the last value from the past and save it in the current.</p><pre>const Component = () =&gt; {
  const [state, setState] = useState({
    current: &quot;&quot;,
    past: [],
  });

  const handleChange = (e) =&gt; {
    setState((oldState) =&gt; {
      const { value } = e.target;
      return {
        ...oldState,
        past: [...oldState.past, oldState.current],
        current: value,
      };
    });
  };

  const undo = () =&gt; {
    setState((oldState) =&gt; {
      if (oldState.past.length === 0) {
        return oldState;
      }
      const newPast = [...oldState.past];
      const pastValue = newPast.pop();

      return {
        ...oldState,
        past: newPast,
        current: pastValue,
      };
    });
  };

  return (
    &lt;div&gt;
      &lt;input type=&quot;text&quot; onChange={handleChange} value={state.current} /&gt;
      &lt;button onClick={undo}&gt;undo&lt;/button&gt;
    &lt;/div&gt;
  );
};</pre><p style="line-height:1.4;font-size:1.125rem;color:#1a1a1a">First we make sure that we have values in the past. If we do not, we return the old state. If we have past states, we break the reference to the old past array, pop the last value and save everything to the new state.</p><p style="line-height:1.4;font-size:1.125rem;color:#1a1a1a">While this works, we have an issue! The past array could grow until we run out of memory. We can prevent this from happening, by limiting the length of the past array. If the array grows beyond a certain limit, we remove values from the beginning of the array, effectively limiting the amount of past states.</p><pre>const Component = () =&gt; {
  const [state, setState] = useState({
    current: &quot;&quot;,
    past: [],
  });

  const handleChange = (e) =&gt; {
    setState((oldState) =&gt; {
      const { value } = e.target;

      let newPast = [];
      if (oldState.past.length &lt;= 10) {
        newPast = [...oldState.past];
      } else {
        const [, /*remove first: the oldest element*/ ...rest] = oldState.past;
        newPast = [...rest];
      }

      return {
        ...oldState,
        past: [...newPast, oldState.current],
        current: value,
      };
    });
  };

  const undo = () =&gt; {
    setState((oldState) =&gt; {
      if (oldState.past.length === 0) {
        return oldState;
      }
      const newPast = [...oldState.past];
      const pastValue = newPast.pop();

      return {
        ...oldState,
        past: newPast,
        current: pastValue,
      };
    });
  };
  
  return (
    &lt;div&gt;
      &lt;input type=&quot;text&quot; onChange={handleChange} value={state.current} /&gt;
      &lt;button onClick={undo}&gt;undo&lt;/button&gt;
    &lt;/div&gt;
  );
};</pre><p style="line-height:1.4;font-size:1.125rem;color:#1a1a1a">If we have more then 10 past states, we remove the first (the oldest) state, preventing the past from growing.</p><p style="line-height:1.4;font-size:1.125rem;color:#1a1a1a">The current implementation works. Lets make this code reusable and move it in to a dedicated hook.</p><pre>const useUndo = (initialState) =&gt; {
  const [state, _setState] = useState({
    current: initialState,
    past: [],
  });

  const undo = () =&gt; {
    _setState((oldState) =&gt; {
      if (oldState.past.length === 0) {
        return oldState;
      }
      const newPast = [...oldState.past];
      const pastValue = newPast.pop();

      return {
        ...oldState,
        past: newPast,
        current: pastValue,
      };
    });
  };

  const setState = (newState) =&gt; {
    _setState((oldState) =&gt; {
      const value =
        typeof newState === &quot;function&quot; ? newState(oldState) : newState;

      let newPast = [];
      if (oldState.past.length &lt;= 10) {
        newPast = [...oldState.past];
      } else {
        const [, /*remove first: the oldest element*/ ...rest] = oldState.past;
        newPast = [...rest];
      }

      return {
        ...oldState,
        past: [...newPast, oldState.current],
        current: value,
      };
    });
  };

  return [state.current, { setState, undo }];
};

const Component = () =&gt; {
  const [state, { setState, undo }] = useUndo(&quot;&quot;);

  const handleChange = (e) =&gt; {
    setState(e.target.value);
  };

  return (
    &lt;div&gt;
      &lt;input type=&quot;text&quot; onChange={handleChange} value={state} /&gt;
      &lt;button onClick={undo}&gt;undo&lt;/button&gt;
    &lt;/div&gt;
  );
};</pre><p style="line-height:1.4;font-size:1.125rem;color:#1a1a1a">It would be great to redo changes again. If the user undoes changes, goes in to the past, it would be great to go in to the future again to the last changes. I would encourage you to implement this feature yourself. If youre interested in seeing the end result, feel free to open the drop down.</p><details><summary style="cursor:pointer">End result</summary><pre>const useUndo = (initialState) =&gt; {
  const [state, _setState] = useState({
    past: [],
    initialState: initialState,
    current: initialState,
    future: [],
  });

  const setState = (newState) =&gt; {
    _setState((oldState) =&gt; {
      let newPast = [];
      if (oldState.past.length &lt;= 10) {
        newPast = [...oldState.past, oldState.current];
      } else {
        const [, /*remove first: the oldest element*/ ...rest] = oldState.past;
        newPast = [...rest, oldState.current];
      }
      return {
        ...oldState,
        past: newPast,
        current:
          typeof newState === &quot;function&quot;
            ? newState(oldState.current)
            : newState,
        future: [],
      };
    });
  };

  const undo = () =&gt; {
    _setState((oldState) =&gt; {
      if (oldState.past.length === 0) {
        return oldState;
      }
      const newFuture = [...oldState.future, oldState.current];

      let newPast = [...oldState.past];
      const newState = newPast.pop();

      return {
        ...oldState,
        past: newPast,
        current: newState,
        future: newFuture,
      };
    });
  };

  const redo = () =&gt; {
    _setState((oldState) =&gt; {
      if (oldState.future.length === 0) {
        return oldState;
      }
      const newPast = [...oldState.past, oldState.current];

      const newFuture = [...oldState.future];
      const newState = newFuture.pop();

      return {
        ...oldState,
        past: newPast,
        current: newState,
        future: newFuture,
      };
    });
  };

  const reset = () =&gt; {
    _setState((oldState) =&gt; {
      return {
        ...oldState,
        past: [],
        current: state.initialState,
        future: [],
      };
    });
  };

  return [
    state.current,
    {
      setState,
      undo,
      redo,
      reset,
      canUndo: state.past.length &gt; 0,
      canRedo: state.future.length &gt; 0,
    },
  ];
};</pre></details></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{}},"page":"/UndoState","query":{},"buildId":"n796NygtBGS4-RVWA6qV3","assetPrefix":"/advanced-react-pattern","nextExport":true,"autoExport":true,"isFallback":false,"scriptLoader":[]}</script></body></html>