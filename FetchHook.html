<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/advanced-react-pattern/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/advanced-react-pattern/_next/static/chunks/webpack-f9606f09ac75a39a.js" defer=""></script><script src="/advanced-react-pattern/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/advanced-react-pattern/_next/static/chunks/main-958c758f0e3a0160.js" defer=""></script><script src="/advanced-react-pattern/_next/static/chunks/pages/_app-86ba28c549340a29.js" defer=""></script><script src="/advanced-react-pattern/_next/static/chunks/170-d59642f47b4b233e.js" defer=""></script><script src="/advanced-react-pattern/_next/static/chunks/113-d639edb2cd38db67.js" defer=""></script><script src="/advanced-react-pattern/_next/static/chunks/292-3dc0c1f448e2d9e8.js" defer=""></script><script src="/advanced-react-pattern/_next/static/chunks/pages/FetchHook-b5cc0ed13556e6b0.js" defer=""></script><script src="/advanced-react-pattern/_next/static/gysrHlmYvuClLDStz8OCU/_buildManifest.js" defer=""></script><script src="/advanced-react-pattern/_next/static/gysrHlmYvuClLDStz8OCU/_ssgManifest.js" defer=""></script><script src="/advanced-react-pattern/_next/static/gysrHlmYvuClLDStz8OCU/_middlewareManifest.js" defer=""></script><style data-styled="" data-styled-version="5.3.5">html{-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%;}/*!sc*/
body{font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;margin:0;padding:0;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;}/*!sc*/
figure{margin:0;}/*!sc*/
.hljs{background:#f6f6f6;border-radius:.5rem;padding:2rem 1rem 2rem 2rem;color:black;font-size:.95rem;line-height:1.25;}/*!sc*/
.xml .hljs-meta{color:#c0c0c0;}/*!sc*/
.hljs-comment,.hljs-quote{color:#007400;}/*!sc*/
.hljs-tag,.hljs-attribute,.hljs-keyword,.hljs-selector-tag,.hljs-literal,.hljs-name{color:#aa0d91;}/*!sc*/
.hljs-variable,.hljs-template-variable{color:#3F6E74;}/*!sc*/
.hljs-code,.hljs-string,.hljs-meta .hljs-string{color:#c41a16;}/*!sc*/
.hljs-regexp,.hljs-link{color:#0E0EFF;}/*!sc*/
.hljs-title,.hljs-symbol,.hljs-bullet,.hljs-number{color:#1c00cf;}/*!sc*/
.hljs-section,.hljs-meta{color:#643820;}/*!sc*/
.hljs-title.class_,.hljs-class .hljs-title,.hljs-type,.hljs-built_in,.hljs-params{color:#5c2699;}/*!sc*/
.hljs-attr{color:#836C28;}/*!sc*/
.hljs-subst{color:#000;}/*!sc*/
.hljs-formula{background-color:#eee;font-style:italic;}/*!sc*/
.hljs-addition{background-color:#baeeba;}/*!sc*/
.hljs-deletion{background-color:#ffc8bd;}/*!sc*/
.hljs-selector-id,.hljs-selector-class{color:#9b703f;}/*!sc*/
.hljs-doctag,.hljs-strong{font-weight:bold;}/*!sc*/
.hljs-emphasis{font-style:italic;}/*!sc*/
data-styled.g1[id="sc-global-eTUlez1"]{content:"sc-global-eTUlez1,"}/*!sc*/
.fHFsLe{white-space:nowrap;line-height:1.5;}/*!sc*/
data-styled.g2[id="Li__Styled-sc-2pbekf-0"]{content:"fHFsLe,"}/*!sc*/
.jfHJAM{margin-right:auto;margin-left:auto;padding-right:15px;padding-left:15px;width:100%;}/*!sc*/
@media screen and (max-width:575px){.jfHJAM{min-width:97vw;}}/*!sc*/
@media screen and (min-width:576px){.jfHJAM{max-width:1024px;}}/*!sc*/
data-styled.g3[id="Container__Styled-sc-zkefve-0"]{content:"jfHJAM,"}/*!sc*/
</style></head><body><div id="__next"><div class="Container__Styled-sc-zkefve-0 jfHJAM"><div style="display:flex;flex-direction:row"><div style="margin-right:1rem"><nav><ul style="padding-left:1rem"><li class="Li__Styled-sc-2pbekf-0 fHFsLe"><a href="/advanced-react-pattern">Home</a></li><li class="Li__Styled-sc-2pbekf-0 fHFsLe"><h4>Utils</h4><ul style="padding-left:1rem"><li class="Li__Styled-sc-2pbekf-0 fHFsLe"><a href="/advanced-react-pattern/Prefetch">Prefetched State</a></li><li class="Li__Styled-sc-2pbekf-0 fHFsLe"><a href="/advanced-react-pattern/StateSubscription">State Subscription</a></li></ul></li><li class="Li__Styled-sc-2pbekf-0 fHFsLe"><h4>Components</h4><ul style="padding-left:1rem"><li class="Li__Styled-sc-2pbekf-0 fHFsLe"><a href="/advanced-react-pattern/suspense">Suspense</a></li><li class="Li__Styled-sc-2pbekf-0 fHFsLe"><a href="/advanced-react-pattern/CompoundToggle">Compound Components</a></li><li class="Li__Styled-sc-2pbekf-0 fHFsLe"><a href="/advanced-react-pattern/StateReducer">State Reducer</a></li><li class="Li__Styled-sc-2pbekf-0 fHFsLe"><a href="/advanced-react-pattern/PropCollection">Props Collection</a></li><li class="Li__Styled-sc-2pbekf-0 fHFsLe"><a href="/advanced-react-pattern/RenderPropsToggle">Render Props</a></li><li class="Li__Styled-sc-2pbekf-0 fHFsLe"><a href="/advanced-react-pattern/Factory">Factory</a></li><li class="Li__Styled-sc-2pbekf-0 fHFsLe"><a href="/advanced-react-pattern/ControlProps">Control Props</a></li><li class="Li__Styled-sc-2pbekf-0 fHFsLe"><a href="/advanced-react-pattern/Decorator">Decorator</a></li></ul></li><li class="Li__Styled-sc-2pbekf-0 fHFsLe"><h4>Hooks</h4><ul style="padding-left:1rem"><li class="Li__Styled-sc-2pbekf-0 fHFsLe"><a href="/advanced-react-pattern/ReducerHook">Reducer Hook</a></li><li class="Li__Styled-sc-2pbekf-0 fHFsLe"><a href="/advanced-react-pattern/UndoState">Undo State</a></li><li class="Li__Styled-sc-2pbekf-0 fHFsLe"><a href="/advanced-react-pattern/ThunkReducer">Thunk Reducer</a></li><li class="Li__Styled-sc-2pbekf-0 fHFsLe"><a href="/advanced-react-pattern/FetchHook">Fetch Hook</a></li></ul></li></ul></nav></div><div><div><div itemscope="" itemType="https://schema.org/BlogPosting"><div itemProp="headline"><h1 style="font-size:2rem">The useFetch hook</h1></div><div itemProp="author" itemscope="" itemType="https://schema.org/Person"><div>Author:<span itemProp="name"> <!-- -->Stanislav Panchenko</span></div><div>URL:<a itemProp="url" href="https://github.com/rilexus">https://github.com/rilexus</a></div></div><div itemProp="datePublished">Published at: <!-- -->August 19, 2022</div><div itemProp="articleBody" style="margin-bottom:2rem"><div><p style="line-height:1.4;font-size:1.125rem;color:#1a1a1a">Fetching data from an endpoint on mount is a long tradition in react. Most of the time it looks like this:</p><pre>const Component = () =&gt; {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() =&gt; {
    setLoading(true);
    fetch(&quot;api/data&quot;, {})
      .then((data) =&gt; {
        setData(data);
        setLoading(false);
      })
      .catch((e) =&gt; {
        setError(e);
      });
  }, []);

  return &lt;div&gt;{!loading ? &lt;div&gt;{data}&lt;/div&gt; : null}&lt;/div&gt;;
};</pre><p style="line-height:1.4;font-size:1.125rem;color:#1a1a1a">We handle 3 states a once for one fetch operation: one for the data, one for the loading state and one for the error. Here we postpone rendering as long as the loading state is true.</p><p style="line-height:1.4;font-size:1.125rem;color:#1a1a1a">This pattern is often times repeated though out the application again and again. That should not be the case, especially because this pattern is very easy to abstract:</p><pre>const Component = () =&gt; {
  const { data, loading, error } = useFetch(async () =&gt; fetch(&quot;api/data&quot;, {}));

  return &lt;div&gt;{!loading ? &lt;div&gt;{data}&lt;/div&gt; : null}&lt;/div&gt;;
};</pre><p style="line-height:1.4;font-size:1.125rem;color:#1a1a1a">Look how tiny and cute this is!</p><p style="line-height:1.4;font-size:1.125rem;color:#1a1a1a">The implementation of the fetch hook is very simple:</p><pre>const useFetch = (fetcher) =&gt; {
  const mounted = useRef(true);

  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() =&gt; {
    fetcher()
      .then((data) =&gt; {
        if (mounted.current) {
          setData(data);
          setLoading(false);
        }
      })
      .catch((e) =&gt; {
        if (mounted.current) {
          setError(e);
          setLoading(false);
        }
      });

    return () =&gt; {
      mounted.current = false;
    };
  }, []);

  return { data, loading, error };
};</pre><p style="line-height:1.4;font-size:1.125rem;color:#1a1a1a">With this we do not need to repeat ourself. All the necessary logic is hidden in the hook. We do not need to think about handling multiple states ourself.</p><p style="line-height:1.4;font-size:1.125rem;color:#1a1a1a">We can go one step further and pass more options to the hook. For example, we would like to decide, if we fetch on mount of not. And if not, we would like to trigger the fetch call ourself.</p><pre>const useFetch = ({ get, onMount = true }) =&gt; {
  const mounted = useRef(true);

  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() =&gt; {
    if (!onMount) return;
    get()
      .then((data) =&gt; {
        if (mounted.current) {
          setData(data);
          setLoading(false);
        }
      })
      .catch((e) =&gt; {
        if (mounted.current) {
          setError(e);
          setLoading(false);
        }
      });

    return () =&gt; {
      mounted.current = false;
    };
  }, []);

  const refetch = useCallback(
    (...args) =&gt; {
      setLoading(true);
      get(...args)
        .then((data) =&gt; {
          if (mounted.current) {
            setLoading(false);
            setData(data);
          }
        })
        .catch((e) =&gt; {
          if (mounted.current) {
            setLoading(false);
            setError(e);
          }
        });
    },
    [get]
  );

  return { data, loading, error, refetch };
};</pre><p style="line-height:1.4;font-size:1.125rem;color:#1a1a1a">The main change is the refetch function. We pass all arguments from the refetch to the get function. Effectively we predefine the API getter and invoke it later in time:</p><pre>const Component = () =&gt; {
  const { data, loading, error, refetch } = useFetch({
    get: async ({ id }) =&gt; fetch(`api/users?id=${id}`, {}),
    onMount: false,
  });

  return (
    &lt;div&gt;
      {!loading ? (
        &lt;div&gt;
          &lt;button
            onClick={() =&gt; {
              refetch({ id: 1 });
            }}
          &gt;
            get user
          &lt;/button&gt;
        &lt;/div&gt;
      ) : null}
    &lt;/div&gt;
  );
};</pre><img src="https://media.giphy.com/media/WrJ8x0niiblWEoo7hE/giphy.gif" alt=""/></div></div><div style="padding:3rem 0 1rem 0"><meta itemProp="dateCreated" content="August 19, 2022"/><meta itemProp="inLanguage" content="English"/><div itemProp="publisher" itemscope="" itemType="https://schema.org/Organization">Published by:<div>Email: <span itemProp="email">email@stanislavpanchenko.de</span></div><div itemProp="funder" itemscope="" itemType="https://schema.org/Person"><div>Name: <span itemProp="name">Stanislav Panchenko</span></div></div></div><div itemProp="isPartOf" itemscope="" itemType="https://schema.org/CreativeWork"><meta itemProp="url" content="https://rilexus.github.io/advanced-react-pattern/"/></div><div itemProp="copyrightHolder" itemscope="" itemType="https://schema.org/Person">Copyright: <span itemProp="name">Stanislav Panchenko</span></div></div></div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{}},"page":"/FetchHook","query":{},"buildId":"gysrHlmYvuClLDStz8OCU","assetPrefix":"/advanced-react-pattern","nextExport":true,"autoExport":true,"isFallback":false,"scriptLoader":[]}</script></body></html>