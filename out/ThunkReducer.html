<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/advanced-react-pattern/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/advanced-react-pattern/_next/static/chunks/webpack-f9606f09ac75a39a.js" defer=""></script><script src="/advanced-react-pattern/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/advanced-react-pattern/_next/static/chunks/main-958c758f0e3a0160.js" defer=""></script><script src="/advanced-react-pattern/_next/static/chunks/pages/_app-86ba28c549340a29.js" defer=""></script><script src="/advanced-react-pattern/_next/static/chunks/170-d59642f47b4b233e.js" defer=""></script><script src="/advanced-react-pattern/_next/static/chunks/pages/ThunkReducer-fc18356d6d3d7e57.js" defer=""></script><script src="/advanced-react-pattern/_next/static/yHgjSMeN2XTVmgSNxoXgw/_buildManifest.js" defer=""></script><script src="/advanced-react-pattern/_next/static/yHgjSMeN2XTVmgSNxoXgw/_ssgManifest.js" defer=""></script><script src="/advanced-react-pattern/_next/static/yHgjSMeN2XTVmgSNxoXgw/_middlewareManifest.js" defer=""></script><style data-styled="" data-styled-version="5.3.5">html{-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%;}/*!sc*/
body{font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;margin:0;padding:0;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;}/*!sc*/
figure{margin:0;}/*!sc*/
.hljs{background:#f6f6f6;border-radius:.5rem;padding:2rem 1rem 2rem 2rem;color:black;font-size:.95rem;line-height:1.25;}/*!sc*/
.xml .hljs-meta{color:#c0c0c0;}/*!sc*/
.hljs-comment,.hljs-quote{color:#007400;}/*!sc*/
.hljs-tag,.hljs-attribute,.hljs-keyword,.hljs-selector-tag,.hljs-literal,.hljs-name{color:#aa0d91;}/*!sc*/
.hljs-variable,.hljs-template-variable{color:#3F6E74;}/*!sc*/
.hljs-code,.hljs-string,.hljs-meta .hljs-string{color:#c41a16;}/*!sc*/
.hljs-regexp,.hljs-link{color:#0E0EFF;}/*!sc*/
.hljs-title,.hljs-symbol,.hljs-bullet,.hljs-number{color:#1c00cf;}/*!sc*/
.hljs-section,.hljs-meta{color:#643820;}/*!sc*/
.hljs-title.class_,.hljs-class .hljs-title,.hljs-type,.hljs-built_in,.hljs-params{color:#5c2699;}/*!sc*/
.hljs-attr{color:#836C28;}/*!sc*/
.hljs-subst{color:#000;}/*!sc*/
.hljs-formula{background-color:#eee;font-style:italic;}/*!sc*/
.hljs-addition{background-color:#baeeba;}/*!sc*/
.hljs-deletion{background-color:#ffc8bd;}/*!sc*/
.hljs-selector-id,.hljs-selector-class{color:#9b703f;}/*!sc*/
.hljs-doctag,.hljs-strong{font-weight:bold;}/*!sc*/
.hljs-emphasis{font-style:italic;}/*!sc*/
data-styled.g1[id="sc-global-eTUlez1"]{content:"sc-global-eTUlez1,"}/*!sc*/
.jfHJAM{margin-right:auto;margin-left:auto;padding-right:15px;padding-left:15px;width:100%;}/*!sc*/
@media screen and (max-width:575px){.jfHJAM{min-width:97vw;}}/*!sc*/
@media screen and (min-width:576px){.jfHJAM{max-width:1024px;}}/*!sc*/
data-styled.g2[id="Container__Styled-sc-zkefve-0"]{content:"jfHJAM,"}/*!sc*/
.fHFsLe{white-space:nowrap;line-height:1.5;}/*!sc*/
data-styled.g3[id="Li__Styled-sc-2pbekf-0"]{content:"fHFsLe,"}/*!sc*/
</style></head><body><div id="__next"><div class="Container__Styled-sc-zkefve-0 jfHJAM"><div style="display:flex;flex-direction:row"><div style="margin-right:1rem"><nav><ul style="padding-left:1rem"><li class="Li__Styled-sc-2pbekf-0 fHFsLe"><a href="/advanced-react-pattern">Home</a></li><li class="Li__Styled-sc-2pbekf-0 fHFsLe"><h4>Utils</h4><ul style="padding-left:1rem"><li class="Li__Styled-sc-2pbekf-0 fHFsLe"><a href="/advanced-react-pattern/Prefetch">Prefetched State</a></li><li class="Li__Styled-sc-2pbekf-0 fHFsLe"><a href="/advanced-react-pattern/StateSubscription">State Subscription</a></li></ul></li><li class="Li__Styled-sc-2pbekf-0 fHFsLe"><h4>Components</h4><ul style="padding-left:1rem"><li class="Li__Styled-sc-2pbekf-0 fHFsLe"><a href="/advanced-react-pattern/suspense">Suspense</a></li><li class="Li__Styled-sc-2pbekf-0 fHFsLe"><a href="/advanced-react-pattern/CompoundToggle">Compound Components</a></li><li class="Li__Styled-sc-2pbekf-0 fHFsLe"><a href="/advanced-react-pattern/StateReducer">State Reducer</a></li><li class="Li__Styled-sc-2pbekf-0 fHFsLe"><a href="/advanced-react-pattern/PropCollection">Props Collection</a></li><li class="Li__Styled-sc-2pbekf-0 fHFsLe"><a href="/advanced-react-pattern/RenderPropsToggle">Render Props</a></li><li class="Li__Styled-sc-2pbekf-0 fHFsLe"><a href="/advanced-react-pattern/Factory">Factory</a></li><li class="Li__Styled-sc-2pbekf-0 fHFsLe"><a href="/advanced-react-pattern/ControlProps">Control Props</a></li><li class="Li__Styled-sc-2pbekf-0 fHFsLe"><a href="/advanced-react-pattern/Decorator">Decorator</a></li></ul></li><li class="Li__Styled-sc-2pbekf-0 fHFsLe"><h4>Hooks</h4><ul style="padding-left:1rem"><li class="Li__Styled-sc-2pbekf-0 fHFsLe"><a href="/advanced-react-pattern/ReducerHook">Reducer Hook</a></li><li class="Li__Styled-sc-2pbekf-0 fHFsLe"><a href="/advanced-react-pattern/ThunkReducer">Thunk Reducer</a></li></ul></li></ul></nav></div><div><div><h1>Thunk Reducer</h1><p style="line-height:1.4;font-size:1.125rem;color:#1a1a1a">this article builds on top of the previous &quot;Reducer Hook&quot; article. If you do not know how the &quot;useReducer&quot; hook works, take a look<!-- --> <a href="/advanced-react-pattern/advanced-react-pattern/ReducerHook">here</a></p><p style="line-height:1.4;font-size:1.125rem;color:#1a1a1a">A typical useReducer implementation looks like this:</p><pre>const reducer = (state, action) =&gt; {
  if (action.type === &quot;any-action&quot;) {
    // TODO: handle action here
    return state;
  }
  return state;
};

const initialState = {};

const Reducer = () =&gt; {
  const [state, dispatch] = useReducer(reducer, initialState);

  const handle = () =&gt; {
    dispatch({ type: &quot;any-action&quot; });
  };

  return (
    &lt;div&gt;
      &lt;button onClick={handle}&gt;Click&lt;/button&gt;
    &lt;/div&gt;
  );
};</pre><p style="line-height:1.4;font-size:1.125rem;color:#1a1a1a">Sometimes its necessary to dispatch multiple actions during the execution of one function. For example, if you would like to fetch data, display a loading message and handle an error during the process like so:</p><pre>const loadingReducer = (state, action) =&gt; {
  if (action.type === &quot;fetching&quot;) {
    // TODO: handle action here
    return state;
  }
  if (action.type === &quot;fetched&quot;) {
    // TODO: handle action here
    return state;
  }
  if (action.type === &quot;error&quot;) {
    // TODO: handle action here
    return state;
  }
  return state;
};

const initialLoadingState = {
  loading: false,
  data: null,
  error: null,
};

const LoadingReducer = () =&gt; {
  const [state, dispatch] = useReducer(loadingReducer, initialLoadingState);

  const handle = () =&gt; {
    dispatch({ type: &quot;loading&quot; });
    fetch()
      .then((data) =&gt; {
        dispatch({ type: &quot;fetched&quot;, data });
      })
      .catch((error) =&gt; {});
    dispatch({ type: &quot;error&quot;, error });
  };

  return (
    &lt;div&gt;
      &lt;button onClick={handle}&gt;Click&lt;/button&gt;
    &lt;/div&gt;
  );
};</pre><p style="line-height:1.4;font-size:1.125rem;color:#1a1a1a">This works but its not very handy and messy to test. We can move the dispatch and fetch logic to a dedicated function like so:</p><pre>const fetchAndDispatch = (dispatch) =&gt; {
  dispatch({ type: &quot;loading&quot; });

  fetch()
    .then((data) =&gt; {
      dispatch({ type: &quot;fetched&quot;, data });
    })
    .catch((error) =&gt; {});
  dispatch({ type: &quot;error&quot;, error });
};

const LoadingReducer = () =&gt; {
  const [state, dispatch] = useReducer(loadingReducer, initialLoadingState);

  const handle = () =&gt; {
    fetchAndDispatch(dispatch);
  };

  return (
    &lt;div&gt;
      &lt;button onClick={handle}&gt;Click&lt;/button&gt;
    &lt;/div&gt;
  );
};</pre><p style="line-height:1.4;font-size:1.125rem;color:#1a1a1a">This is definitely a better solution. We pass the dispatch function as an argument to the &quot;fetchAndDispatch&quot; function. Now the function is pretty good testable:</p><pre>describe(&quot;fetchAndDispatch&quot;, () =&gt; {
  it(&quot;should dispatch actions&quot;, () =&gt; {
    fetch.mockImplementationOnce(() =&gt; Promise.reject(&quot;API is down&quot;));
    
    const mockedDispatch = jest.fn();
    fetchAndDispatch(mockedDispatch);
    
    expect(mockedDispatch).toBeCalledWith({type: &#x27;fetching&#x27;})
    expect(mockedDispatch).toBeCalledWith({type: &#x27;error&#x27;})
    // TODO: test the happy path
  });
});</pre><p style="line-height:1.4;font-size:1.125rem;color:#1a1a1a">but we do not have a good way to pass additional arguments to the function anymore.</p><pre>const fetchAndDispatch = (dispatch, arg1, arg2, arg3 /* ... */) =&gt; {
  dispatch({ type: &quot;loading&quot; });

  fetch()
    .then((data) =&gt; {
      dispatch({ type: &quot;fetched&quot;, data });
    })
    .catch((error) =&gt; {});
  dispatch({ type: &quot;error&quot;, error });
};</pre><p style="line-height:1.4;font-size:1.125rem;color:#1a1a1a">What we can do is to return a function which accepts the &quot;dispatch&quot; function:</p><pre>const fetchAndDispatch = (arg1, arg2, arg3 /* ... */) =&gt; {
  return (dispatch) =&gt; {
    dispatch({ type: &quot;loading&quot; });

    fetch()
      .then((data) =&gt; {
        dispatch({ type: &quot;fetched&quot;, data });
      })
      .catch((error) =&gt; {});
    dispatch({ type: &quot;error&quot;, error });
  };
};</pre><p style="line-height:1.4;font-size:1.125rem;color:#1a1a1a">A concrete implementation of this pattern can be:</p><pre>const fetchUser = ({ byId }) =&gt; {
  return (dispatch) =&gt; {
    dispatch({ type: &quot;loading&quot; });

    fetch(`/user/${byId}`)
      .then((data) =&gt; {
        dispatch({ type: &quot;fetched&quot;, data });
      })
      .catch((error) =&gt; {});
    dispatch({ type: &quot;error&quot;, error });
  };
};</pre><p style="line-height:1.4;font-size:1.125rem;color:#1a1a1a">And the component would look like this:</p><pre>const LoadingReducer = () =&gt; {
  const [state, dispatch] = useReducer(loadingReducer, initialLoadingState);

  const handle = () =&gt; {
    fetchUser({ byId: &quot;1234&quot; })(dispatch);
  };

  return (
    &lt;div&gt;
      &lt;button onClick={handle}&gt;Click&lt;/button&gt;
    &lt;/div&gt;
  );
};</pre><p style="line-height:1.4;font-size:1.125rem;color:#1a1a1a">If you think that it looks bad, I agree! I would prefer reverse the order of the calls like so:</p><pre>const LoadingReducer = () =&gt; {
  const [state, dispatch] = useReducer(loadingReducer, initialLoadingState);

  const handle = () =&gt; {
    dispatch(fetchUser({ byId: &quot;1234&quot; }));
  };

  return (
    &lt;div&gt;
      &lt;button onClick={handle}&gt;Click&lt;/button&gt;
    &lt;/div&gt;
  );
};</pre><p style="line-height:1.4;font-size:1.125rem;color:#1a1a1a">To make this possible, the dispatch function would need to accept a function as an argument. The native &quot;dispatch&quot; provided by &quot;react&quot; does not support that. To make something similar, we can extend on the native &quot;dispatch&quot;:</p><pre>const LoadingReducer = () =&gt; {
  const [state, nativeDispatch] = useReducer(
    loadingReducer,
    initialLoadingState
  );

  const dispatch = (actionOrFunction) =&gt; {
    if (typeof actionOrFunction === &quot;function&quot;) {
      actionOrFunction(nativeDispatch);
    } else {
      nativeDispatch(actionOrFunction);
    }
  };

  const handle = () =&gt; {
    dispatch(fetchUser({ byId: &quot;1234&quot; }));
  };

  return (
    &lt;div&gt;
      &lt;button onClick={handle}&gt;Click&lt;/button&gt;
    &lt;/div&gt;
  );
};</pre><p style="line-height:1.4;font-size:1.125rem;color:#1a1a1a">Implementing the custom dispatch every time we need it, is time consuming and annoying. Therefore, I would suggest to move it to a custom hook:</p><pre>import { useReducer as nativeUseReducerHook } from &quot;react&quot;;

const useReducer = (reducer, initState, initializer) =&gt; {
  const [state, nativeDispatch] = nativeUseReducerHook(
    reducer,
    initState,
    initializer
  );

  const dispatch = (actionOrFunction) =&gt; {
    if (typeof actionOrFunction === &quot;function&quot;) {
      actionOrFunction(nativeDispatch);
    } else {
      nativeDispatch(actionOrFunction);
    }
  };

  return [state, dispatch];
};

export { useReducer };</pre><p style="line-height:1.4;font-size:1.125rem;color:#1a1a1a">From now on, as long as we use the custom hook, we can pass functions to the &quot;dispatch&quot; function and dispatch actions asynchronously easily.</p><p style="line-height:1.4;font-size:1.125rem;color:#1a1a1a">If you would like to read more about this pattern, feel free to take a look<!-- --> <a href="https://redux.js.org/usage/writing-logic-thunks">here</a>.</p></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{}},"page":"/ThunkReducer","query":{},"buildId":"yHgjSMeN2XTVmgSNxoXgw","assetPrefix":"/advanced-react-pattern","nextExport":true,"autoExport":true,"isFallback":false,"scriptLoader":[]}</script></body></html>