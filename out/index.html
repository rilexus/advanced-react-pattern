<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/advanced-react-pattern/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/advanced-react-pattern/_next/static/chunks/webpack-1114306cd7089e72.js" defer=""></script><script src="/advanced-react-pattern/_next/static/chunks/framework-d51ece3d757c7ed2.js" defer=""></script><script src="/advanced-react-pattern/_next/static/chunks/main-e5ef016c3425ef5b.js" defer=""></script><script src="/advanced-react-pattern/_next/static/chunks/pages/_app-8c5bff8b4ce56d50.js" defer=""></script><script src="/advanced-react-pattern/_next/static/chunks/939-b1f31649ec1515fe.js" defer=""></script><script src="/advanced-react-pattern/_next/static/chunks/7952-384e36bf38684cb1.js" defer=""></script><script src="/advanced-react-pattern/_next/static/chunks/pages/index-50dcb1ce25cedeb9.js" defer=""></script><script src="/advanced-react-pattern/_next/static/ERDtAF2AnkiOE8NbNtW-f/_buildManifest.js" defer=""></script><script src="/advanced-react-pattern/_next/static/ERDtAF2AnkiOE8NbNtW-f/_ssgManifest.js" defer=""></script><script src="/advanced-react-pattern/_next/static/ERDtAF2AnkiOE8NbNtW-f/_middlewareManifest.js" defer=""></script><style data-styled="" data-styled-version="5.3.5">html{-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%;}/*!sc*/
body{font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;margin:0;padding:0;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;}/*!sc*/
data-styled.g1[id="sc-global-jbFqTx1"]{content:"sc-global-jbFqTx1,"}/*!sc*/
.jfHJAM{margin-right:auto;margin-left:auto;padding-right:15px;padding-left:15px;width:100%;}/*!sc*/
@media screen and (max-width:575px){.jfHJAM{min-width:97vw;}}/*!sc*/
@media screen and (min-width:576px){.jfHJAM{max-width:1024px;}}/*!sc*/
data-styled.g2[id="Container__Styled-sc-zkefve-0"]{content:"jfHJAM,"}/*!sc*/
.fHFsLe{white-space:nowrap;line-height:1.5;}/*!sc*/
data-styled.g6[id="Li__Styled-sc-2pbekf-0"]{content:"fHFsLe,"}/*!sc*/
</style></head><body><div id="__next"><div class="Container__Styled-sc-zkefve-0 jfHJAM"><div style="display:flex;flex-direction:row"><div style="margin-right:1rem"><nav><ul style="padding-left:1rem"><li class="Li__Styled-sc-2pbekf-0 fHFsLe"><a href="/advanced-react-pattern">Home</a></li><li class="Li__Styled-sc-2pbekf-0 fHFsLe"><h4>Utils</h4><ul style="padding-left:1rem"><li class="Li__Styled-sc-2pbekf-0 fHFsLe"><a href="/advanced-react-pattern/Prefetch">Prefetched State</a></li><li class="Li__Styled-sc-2pbekf-0 fHFsLe"><a href="/advanced-react-pattern/StateSubscription">State Subscription</a></li></ul></li><li class="Li__Styled-sc-2pbekf-0 fHFsLe"><h4>Components</h4><ul style="padding-left:1rem"><li class="Li__Styled-sc-2pbekf-0 fHFsLe"><a href="/advanced-react-pattern/CompoundToggle">Compound Components</a></li><li class="Li__Styled-sc-2pbekf-0 fHFsLe"><a href="/advanced-react-pattern/StateReducer">State Reducer</a></li><li class="Li__Styled-sc-2pbekf-0 fHFsLe"><a href="/advanced-react-pattern/PropCollection">Props Collection</a></li><li class="Li__Styled-sc-2pbekf-0 fHFsLe"><a href="/advanced-react-pattern/RenderPropsToggle">Render Props</a></li><li class="Li__Styled-sc-2pbekf-0 fHFsLe"><a href="/advanced-react-pattern/Factory">Factory</a></li><li class="Li__Styled-sc-2pbekf-0 fHFsLe"><a href="/advanced-react-pattern/ControlProps">Control Props</a></li><li class="Li__Styled-sc-2pbekf-0 fHFsLe"><a href="/advanced-react-pattern/Decorator">Decorator</a></li></ul></li><li class="Li__Styled-sc-2pbekf-0 fHFsLe"><h4>Hooks</h4><ul style="padding-left:1rem"><li class="Li__Styled-sc-2pbekf-0 fHFsLe"><a href="/advanced-react-pattern/ThunkReducer">Thunk Reducer</a></li><li class="Li__Styled-sc-2pbekf-0 fHFsLe"><a href="/advanced-react-pattern/ReducerHook">Reducer Hook</a></li></ul></li></ul></nav></div><div><h1 class="Title-sc-10ps33z-0 egycTu">Advanced React Patterns</h1><p style="line-height:1.4;font-size:1.125rem;color:#1a1a1a">I would like to clarify a misconception that a lot of junior to mid level developers have regarding react components. Namely that a react component is not some magic, it is a regular javascript function and can be treated like one.</p><p style="line-height:1.4;font-size:1.125rem;color:#1a1a1a">The first moment of confusion for me was that one time as I spoke with a junior developer and I have proposed to change this implementation:</p><div style="margin:1rem 0;font-size:.9rem"><span style="font-size:inherit;font-family:inherit;background:#f3f3f3;color:#25282a;border-radius:3px;display:flex;line-height:1.4285714285714286;overflow-x:auto;white-space:pre"><code style="font-size:inherit;font-family:inherit;line-height:1.6666666666666667;padding:8px">const Component = () =&gt; {
  const [count, setCount] = useState(10);

  useEffect(() =&gt; {
    if (count === 0) {
      dispatch({ type: &quot;some-action&quot; });
    }
  }, [count]);

  return (
    &lt;div&gt;
      &lt;button
        onClick={() =&gt; {
          setCount((c) =&gt; c - 1);
        }}
      &gt;
        Decrement
      &lt;/button&gt;
    &lt;/div&gt;
  );
};</code></span></div><p style="line-height:1.4;font-size:1.125rem;color:#1a1a1a">to this one:</p><div style="margin:1rem 0;font-size:.9rem"><span style="font-size:inherit;font-family:inherit;background:#f3f3f3;color:#25282a;border-radius:3px;display:flex;line-height:1.4285714285714286;overflow-x:auto;white-space:pre"><code style="font-size:inherit;font-family:inherit;line-height:1.6666666666666667;padding:8px">const Component = () =&gt; {
  const [count, setCount] = useState(10);

  if (count === 0) {
    dispatch({ type: &quot;some-action&quot; });
  }
  return (
    &lt;div&gt;
      &lt;button
        onClick={() =&gt; {
          setCount((c) =&gt; c - 1);
        }}
      &gt;
        Decrement
      &lt;/button&gt;
    &lt;/div&gt;
  );
};</code></span></div><p style="line-height:1.4;font-size:1.125rem;color:#1a1a1a">essentially I have proposed to remove the useEffect from the component.</p><p style="line-height:1.4;font-size:1.125rem;color:#1a1a1a">At that moment I could sense the confusion of the developer. No! Thats not how it suppose to work. We need the useEffect, so react knows when the counter has changed. He says. But react knows when the counter has changed after you called the setState function. I reply. Yes true, but how does react suppose to know when to call the dispatch function? He says. It does no need to know that. I say. But then the dispatch will not be called ... . He says. We went like this for couple of minutes till I understood that he has a conception of components where he could execute calculations only in hooks like useMemo, useCallback, useEffect and functions defined inside the hook. The execution context of the components function is of limit!</p><p style="line-height:1.4;font-size:1.125rem;color:#1a1a1a">To make sure that I understood his misconception correctly, I have asked him to write a component, the user can enter his first name in one input, the last name in another and the component should display the full name.</p><p style="line-height:1.4;font-size:1.125rem;color:#1a1a1a">This was his solution:</p><div style="margin:1rem 0;font-size:.9rem"><span style="font-size:inherit;font-family:inherit;background:#f3f3f3;color:#25282a;border-radius:3px;display:flex;line-height:1.4285714285714286;overflow-x:auto;white-space:pre"><code style="font-size:inherit;font-family:inherit;line-height:1.6666666666666667;padding:8px">const Component = () =&gt; {
  const [firstName, setFirstName] = useState(&quot;&quot;);
  const [lastName, setLastName] = useState(&quot;&quot;);
  const [fullName, setFullName] = useState(&quot;&quot;);

  useEffect(() =&gt; {
    setFullName(`${firstName} ${lastName}`);
  }, [firstName, lastName]);

  return (
    &lt;div&gt;
      &lt;div&gt;{fullName}&lt;/div&gt;
      &lt;div&gt;
        &lt;input
          type=&quot;text&quot;
          onChange={(e) =&gt; setFirstName(e.target.value)}
          value={firstName}
        /&gt;
        &lt;input
          type=&quot;text&quot;
          onChange={(e) =&gt; setLastName(e.target.value)}
          value={lastName}
        /&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
};</code></span></div><div style="text-align:center"><img src="https://media.giphy.com/media/SVgKToBLI6S6DUye1Y/giphy.gif" alt=""/></div><p style="line-height:1.4;font-size:1.125rem;color:#1a1a1a">I have proposed this solution</p><div style="margin:1rem 0;font-size:.9rem"><span style="font-size:inherit;font-family:inherit;background:#f3f3f3;color:#25282a;border-radius:3px;display:flex;line-height:1.4285714285714286;overflow-x:auto;white-space:pre"><code style="font-size:inherit;font-family:inherit;line-height:1.6666666666666667;padding:8px">const Component = () =&gt; {
  const [firstName, setFirstName] = useState(&quot;&quot;);
  const [lastName, setLastName] = useState(&quot;&quot;);

  const fullName = `${firstName} ${lastName}`;

  return (
    &lt;div&gt;
      &lt;div&gt;{fullName}&lt;/div&gt;
      &lt;div&gt;
        &lt;input
          type=&quot;text&quot;
          onChange={(e) =&gt; setFirstName(e.target.value)}
          value={firstName}
        /&gt;
        &lt;input
          type=&quot;text&quot;
          onChange={(e) =&gt; setLastName(e.target.value)}
          value={lastName}
        /&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
};</code></span></div><p style="line-height:1.4;font-size:1.125rem;color:#1a1a1a">I could see gears spinning in his head.</p><div style="text-align:center"><img src="https://media.giphy.com/media/WRQBXSCnEFJIuxktnw/giphy.gif" alt=""/></div><p style="line-height:1.4;font-size:1.125rem;color:#1a1a1a">No wonders, the &quot;if statement&quot; did not make any sense to him.</p><p style="line-height:1.4;font-size:1.125rem;color:#1a1a1a">I think the confusion results because of the counterintuitive behavior of useState and other react hooks. Just imagine a javascript function will be called again because you call another function within it.</p><p style="line-height:1.4;font-size:1.125rem;color:#1a1a1a">I would like to provide a mental model to demonstrate that a react component is simply a javascript function.</p><p style="line-height:1.4;font-size:1.125rem;color:#1a1a1a">First, one needs to understand what happens with the jsx code during the build time. This code:</p><div style="margin:1rem 0;font-size:.9rem"><span style="font-size:inherit;font-family:inherit;background:#f3f3f3;color:#25282a;border-radius:3px;display:flex;line-height:1.4285714285714286;overflow-x:auto;white-space:pre"><code style="font-size:inherit;font-family:inherit;line-height:1.6666666666666667;padding:8px">const ComponentA = () =&gt; {
  const [state, setState] = useState(1);
  console.log(&quot;here&quot;)		
  return &lt;div&gt;Some&lt;/div&gt;
}

const Component = () =&gt; {
  return &lt;ComponentA/&gt;
}</code></span></div><p style="line-height:1.4;font-size:1.125rem;color:#1a1a1a">is going to be transpiled to this code:</p><div style="margin:1rem 0;font-size:.9rem"><span style="font-size:inherit;font-family:inherit;background:#f3f3f3;color:#25282a;border-radius:3px;display:flex;line-height:1.4285714285714286;overflow-x:auto;white-space:pre"><code style="font-size:inherit;font-family:inherit;line-height:1.6666666666666667;padding:8px">const ComponentA = () =&gt; {
  const [state, setState] = useState(1);
  console.log(&quot;here&quot;);
  return createElement(&quot;div&quot;, null, &quot;Some&quot;);
};

const Component = () =&gt; {
  return createElement(ComponentA, null);
};</code></span></div><p style="line-height:1.4;font-size:1.125rem;color:#1a1a1a">We can rewrite this code like this:</p><div style="margin:1rem 0;font-size:.9rem"><span style="font-size:inherit;font-family:inherit;background:#f3f3f3;color:#25282a;border-radius:3px;display:flex;line-height:1.4285714285714286;overflow-x:auto;white-space:pre"><code style="font-size:inherit;font-family:inherit;line-height:1.6666666666666667;padding:8px">const Component = () =&gt; {
  return createElement(() =&gt; {
    const [state, setState] = useState(1);
    console.log(&quot;here&quot;);
    return createElement(&quot;div&quot;, null, &quot;Some&quot;);
  }, null);
};</code></span></div><p style="line-height:1.4;font-size:1.125rem;color:#1a1a1a">We pass a function</p><div style="margin:1rem 0;font-size:.9rem"><span style="font-size:inherit;font-family:inherit;background:#f3f3f3;color:#25282a;border-radius:3px;display:flex;line-height:1.4285714285714286;overflow-x:auto;white-space:pre"><code style="font-size:inherit;font-family:inherit;line-height:1.6666666666666667;padding:8px">() =&gt; {
  const [state, setState] = useState(1);
  console.log(&quot;here&quot;);
  return createElement(&quot;div&quot;, null, &quot;Some&quot;);
}</code></span></div><p style="line-height:1.4;font-size:1.125rem;color:#1a1a1a">to the &quot;createElement&quot; function. Essentially saying to react: Please call this function for us. Now everytime we call &quot;setState&quot;, react is going to call this function again.</p><p style="line-height:1.4;font-size:1.125rem;color:#1a1a1a">Take a look in to the implementation of this component:</p><div style="margin:1rem 0;font-size:.9rem"><span style="font-size:inherit;font-family:inherit;background:#f3f3f3;color:#25282a;border-radius:3px;display:flex;line-height:1.4285714285714286;overflow-x:auto;white-space:pre"><code style="font-size:inherit;font-family:inherit;line-height:1.6666666666666667;padding:8px">const Component = () =&gt; {
  const [state, setState] = useState(&quot;click me&quot;);
  return (
    &lt;button
      onClick={() =&gt; {
        setState(&quot;clicked&quot;);
      }}
    &gt;
      {state}
    &lt;/button&gt;
  );
};

render(&lt;Component /&gt;, document.getElementById(&quot;root&quot;));</code></span></div><p style="line-height:1.4;font-size:1.125rem;color:#1a1a1a">There is nothing unordinary about it, except that the useState is not from react. The implementation of this useState is as follows:</p><div style="margin:1rem 0;font-size:.9rem"><span style="font-size:inherit;font-family:inherit;background:#f3f3f3;color:#25282a;border-radius:3px;display:flex;line-height:1.4285714285714286;overflow-x:auto;white-space:pre"><code style="font-size:inherit;font-family:inherit;line-height:1.6666666666666667;padding:8px">let state = null;
const useState = (initialState) =&gt; {
  if (state === null) {
    // set state initially, once
    state = initialState;
  }
  const setState = (newState) =&gt; {
    // set new value to state
    state = newState;
    // re-render the Component on every setState call
    render(&lt;Component /&gt;, document.getElementById(&quot;root&quot;));
  };

  // return current state value
  return [state, setState];
};</code></span></div><p style="line-height:1.4;font-size:1.125rem;color:#1a1a1a">As soon, as we call useState, react re-renders our component. This is not how react implements the useState, for sure. It should help to understand how react calls our component/function again as soon as we set new state and most importantly, that<!-- --> <b>we will get the new state on the next call.</b> As if we would define all our variables in the global scope.</p><p style="line-height:1.4;font-size:1.125rem;color:#1a1a1a">The context, the &quot;space&quot; between the component name and the return statement is ours. We can use its as we like, as if this a normal javascript function.</p><div style="margin:1rem 0;font-size:.9rem"><span style="font-size:inherit;font-family:inherit;background:#f3f3f3;color:#25282a;border-radius:3px;display:flex;line-height:1.4285714285714286;overflow-x:auto;white-space:pre"><code style="font-size:inherit;font-family:inherit;line-height:1.6666666666666667;padding:8px">const Component = () =&gt; {
  // our space
  const [state, setState] = useState(1);
  // ...
  // .
  // . our space
  // .
  // ...
  console.log(&quot;here&quot;);
  // ...
  // .
  // . our space
  // .
  // ...
  return React.createElement(&quot;div&quot;, null, &quot;Some&quot;);
};</code></span></div><p style="line-height:1.4;font-size:1.125rem;color:#1a1a1a">The only rule we have to follow, is that we are not allowed to call hooks conditionally:</p><div style="margin:1rem 0;font-size:.9rem"><span style="font-size:inherit;font-family:inherit;background:#f3f3f3;color:#25282a;border-radius:3px;display:flex;line-height:1.4285714285714286;overflow-x:auto;white-space:pre"><code style="font-size:inherit;font-family:inherit;line-height:1.6666666666666667;padding:8px">const Component = () =&gt; {
  const [state, setState] = useState();
  if(condition){
    const [otherState, setOther] = useState();
  }
  if(condition){
    useEffect(() =&gt; {
      console.log(&#x27;here&#x27;);
    }, [])
  }
  return &lt;div&gt;Some&lt;/div&gt;
};</code></span></div><div style="text-align:center"><video loop="" muted="" autoplay="" src="https://media1.giphy.com/media/RHZtYfdXDL9Wqm5949/giphy360p.mp4?cid=790b761111a6898bf1576add44a3b3122f3591464130d5c2&amp;rid=giphy360p.mp4&amp;ct=v&amp;cc=en"></video></div><p style="line-height:1.4;font-size:1.125rem;color:#1a1a1a">The reason for this is, how react associates every hook with a component. If you call a &quot;setState&quot; function, react needs to know from which component it was called and re-render it.</p><p style="line-height:1.4;font-size:1.125rem;color:#1a1a1a">When the component mounts for the first time, react keeps track of how many hooks were called and associates those hooks with the current component. Association of hooks to a component happens on mount and de-association on unmount. If you call a hook conditionally react does not know to which component it belongs. This is a guaranteed bug.</p></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{}},"page":"/","query":{},"buildId":"ERDtAF2AnkiOE8NbNtW-f","assetPrefix":"/advanced-react-pattern","nextExport":true,"autoExport":true,"isFallback":false,"scriptLoader":[]}</script></body></html>