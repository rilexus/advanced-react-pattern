(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[549],{27672:function(t,n,e){"use strict";var a=e(13922),r=e(15234),s=e(9668),o=e(89100),u=e(68556),i=(e(67294),e(85893));n.Z=function(t){var n=t.author,e=n.url,l=n.name,c=t.dataPublished,d=t.title,h=t.content,p=t.dataCreated,S=t.inLanguage,f=t.partfOf,g=t.copyRight,v=g.name,w=g.email,m=t.organisation,j=m.email,x=m.name,y=m.funder.name;return(0,i.jsxs)("div",{children:[(0,i.jsx)(a.Z,{space:"4rem"}),(0,i.jsx)(r.Z,{children:(0,i.jsx)("main",{children:(0,i.jsx)("article",{children:(0,i.jsxs)(s.Z,{children:[(0,i.jsxs)(o.Z,{color:"#6e6e73",children:[(0,i.jsx)(s.Z.Author,{name:l,url:e}),(0,i.jsx)(s.Z.DatePublished,{children:c})]}),(0,i.jsx)(s.Z.Headline,{children:(0,i.jsx)(u.Z,{children:d})}),(0,i.jsx)(s.Z.Body,{style:{marginBottom:"2rem"},children:h}),(0,i.jsxs)("div",{style:{padding:"3rem 0 1rem 0"},children:[(0,i.jsx)(s.Z.DateCreated,{children:p}),(0,i.jsx)(s.Z.Language,{children:S}),(0,i.jsx)(s.Z.Organization,{funder:{name:y},name:x,email:j}),(0,i.jsx)(s.Z.PartOf,{url:f}),(0,i.jsx)(s.Z.CopyRight,{name:v,email:w})]})]})})})})]})}},47183:function(t,n,e){"use strict";e.r(n),e.d(n,{default:function(){return x}});var a=e(17674),r=e(59499),s=e(14666);function o(t){if("undefined"!==typeof Symbol&&null!=t[Symbol.iterator]||null!=t["@@iterator"])return Array.from(t)}var u=e(2937),i=e(14882);var l=e(52587);function c(t){return function(t){if(Array.isArray(t))return(0,l.Z)(t)}(t)||o(t)||(0,u.Z)(t)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}var d=e(67294),h=(e(68556),e(84663)),p=e(43236),S=(e(9668),e(15234),e(29404),e(13922),e(89100),e(27672)),f=e(85893);function g(t,n){var e=Object.keys(t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(t);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(t,n).enumerable}))),e.push.apply(e,a)}return e}function v(t){for(var n=1;n<arguments.length;n++){var e=null!=arguments[n]?arguments[n]:{};n%2?g(Object(e),!0).forEach((function(n){(0,r.Z)(t,n,e[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(e)):g(Object(e)).forEach((function(n){Object.defineProperty(t,n,Object.getOwnPropertyDescriptor(e,n))}))}return t}var w=function(t){var n=(0,d.useState)({past:[],initialState:t,current:t,future:[]}),e=n[0],a=n[1];return[e.current,function(t){a((function(n){var e,a=[];if(n.past.length<=10)a=[].concat(c(n.past),[n.current]);else{var r=(e=n.past,(0,s.Z)(e)||o(e)||(0,u.Z)(e)||(0,i.Z)()).slice(1);a=[].concat(c(r),[n.current])}return v(v({},n),{},{past:a,current:"function"===typeof t?t(n.current):t,future:[]})}))},{undo:function(){a((function(t){if(0===t.past.length)return t;var n=[].concat(c(t.future),[t.current]),e=c(t.past),a=e.pop();return v(v({},t),{},{past:e,current:a,future:n})}))},redo:function(){a((function(t){if(0===t.future.length)return t;var n=[].concat(c(t.past),[t.current]),e=c(t.future),a=e.pop();return v(v({},t),{},{past:n,current:a,future:e})}))},reset:function(){a((function(t){return v(v({},t),{},{past:[],current:e.initialState,future:[]})}))},canUndo:e.past.length>0,canRedo:e.future.length>0}]},m=function(){var t=w(""),n=(0,a.Z)(t,3),e=n[0],r=n[1],s=n[2],o=s.undo,u=s.redo,i=s.reset,l=s.canUndo,c=s.canRedo;return(0,f.jsxs)("div",{children:[(0,f.jsx)("input",{placeholder:"Type",type:"text",value:e,onChange:function(t){r(t.target.value)}}),(0,f.jsx)("button",{disabled:!l,onClick:o,children:"undo"}),(0,f.jsx)("button",{disabled:!c,onClick:u,children:"redo"}),(0,f.jsx)("button",{onClick:i,children:"reset"})]})},j=function(){return(0,f.jsx)("div",{children:(0,f.jsx)(S.Z,{content:(0,f.jsxs)("div",{children:[(0,f.jsx)(h.P,{children:"Very common requirements in some what complex web applications is the \u201cundo\u201c functionality. The user wants to undo the recent changes made in the application by pressing a button. You'll know this behaviour when you press \u201ccommand-z\u201c on mac or \u201cstrg-z\u201c on windows."}),(0,f.jsx)(h.P,{children:"Example:"}),(0,f.jsx)(m,{}),(0,f.jsx)(h.P,{children:"Translating this requirements in to react would means setting the current state of a component to the previous states."}),(0,f.jsx)(h.P,{children:"First we would need a component any state:"}),(0,f.jsx)(p.E,{children:'const Component = () => {\n  const [state, setState] = useState("");\n\n  const handleChange = (e) => {\n    setState(e.target.value);\n  };\n\n  return (\n    <div>\n      <input type="text" onChange={handleChange} value={state} />\n    </div>\n  );\n};'}),(0,f.jsx)(h.P,{children:"When we set a new state, We would need to keep track of all the previous states:"}),(0,f.jsx)(p.E,{highlight:[{start:3,end:4},{start:10,end:14}],children:'const Component = () => {\n  const [state, setState] = useState({\n    current: "",\n    past: [],\n  });\n\n  const handleChange = (e) => {\n    setState((oldState) => {\n      const { value } = e.target;\n      return {\n        ...oldState,\n        past: [...oldState.past, oldState.current],\n        current: value,\n      };\n    });\n  };\n\n  return (\n    <div>\n      <input type="text" onChange={handleChange} value={state.current} />\n    </div>\n  );\n};'}),(0,f.jsx)(h.P,{children:"We save all the past states by adding the current value from the oldState to the past array and in the same time add the new value to the current."}),(0,f.jsx)(p.E,{highlight:[{start:12,end:13}],children:'const Component = () => {\n  const [state, setState] = useState({\n    current: "",\n    past: [],\n  });\n\n  const handleChange = (e) => {\n    setState((oldState) => {\n      const { value } = e.target;\n      return {\n        ...oldState,\n        past: [...oldState.past, oldState.current],\n        current: value,\n      };\n    });\n  };\n\n  return (\n    <div>\n      <input type="text" onChange={handleChange} value={state.current} />\n    </div>\n  );\n};'}),(0,f.jsx)(h.P,{children:"Now to undo the state change, we would need to take the last value from the past and save it in the current."}),(0,f.jsx)(p.E,{highlight:[{start:23,end:24},{start:28,end:29}],children:'const Component = () => {\n  const [state, setState] = useState({\n    current: "",\n    past: [],\n  });\n\n  const handleChange = (e) => {\n    setState((oldState) => {\n      const { value } = e.target;\n      return {\n        ...oldState,\n        past: [...oldState.past, oldState.current],\n        current: value,\n      };\n    });\n  };\n\n  const undo = () => {\n    setState((oldState) => {\n      if (oldState.past.length === 0) {\n        return oldState;\n      }\n      const newPast = [...oldState.past];\n      const pastValue = newPast.pop();\n\n      return {\n        ...oldState,\n        past: newPast,\n        current: pastValue,\n      };\n    });\n  };\n\n  return (\n    <div>\n      <input type="text" onChange={handleChange} value={state.current} />\n      <button onClick={undo}>undo</button>\n    </div>\n  );\n};'}),(0,f.jsx)(h.P,{children:"First we make sure that we have values in the past. If we do not, we return the old state. If we have past states, we break the reference to the old past array, pop the last value and save everything to the new state."}),(0,f.jsx)(h.P,{children:"While this works, we have an issue! The past array could grow until we run out of memory. We can prevent this from happening, by limiting the length of the past array. If the array grows beyond a certain limit, we remove values from the beginning of the array, effectively limiting the amount of past states."}),(0,f.jsx)(p.E,{highlight:[{start:11,end:17}],children:'const Component = () => {\n  const [state, setState] = useState({\n    current: "",\n    past: [],\n  });\n\n  const handleChange = (e) => {\n    setState((oldState) => {\n      const { value } = e.target;\n\n      let newPast = [];\n      if (oldState.past.length <= 10) {\n        newPast = [...oldState.past];\n      } else {\n        const [, /*remove first: the oldest element*/ ...rest] = oldState.past;\n        newPast = [...rest];\n      }\n\n      return {\n        ...oldState,\n        past: [...newPast, oldState.current],\n        current: value,\n      };\n    });\n  };\n\n  const undo = () => {\n    setState((oldState) => {\n      if (oldState.past.length === 0) {\n        return oldState;\n      }\n      const newPast = [...oldState.past];\n      const pastValue = newPast.pop();\n\n      return {\n        ...oldState,\n        past: newPast,\n        current: pastValue,\n      };\n    });\n  };\n  \n  return (\n    <div>\n      <input type="text" onChange={handleChange} value={state.current} />\n      <button onClick={undo}>undo</button>\n    </div>\n  );\n};'}),(0,f.jsx)(h.P,{children:"If we have more then 10 past states, we remove the first (the oldest) state, preventing the past from growing."}),(0,f.jsx)(h.P,{children:"The current implementation works. Lets make this code reusable and move it in to a dedicated hook."}),(0,f.jsx)(p.E,{highlight:[{start:48,end:48}],children:'const useUndo = (initialState) => {\n  const [state, _setState] = useState({\n    current: initialState,\n    past: [],\n  });\n\n  const undo = () => {\n    _setState((oldState) => {\n      if (oldState.past.length === 0) {\n        return oldState;\n      }\n      const newPast = [...oldState.past];\n      const pastValue = newPast.pop();\n\n      return {\n        ...oldState,\n        past: newPast,\n        current: pastValue,\n      };\n    });\n  };\n\n  const setState = (newState) => {\n    _setState((oldState) => {\n      const value =\n        typeof newState === "function" ? newState(oldState) : newState;\n\n      let newPast = [];\n      if (oldState.past.length <= 10) {\n        newPast = [...oldState.past];\n      } else {\n        const [, /*remove first: the oldest element*/ ...rest] = oldState.past;\n        newPast = [...rest];\n      }\n\n      return {\n        ...oldState,\n        past: [...newPast, oldState.current],\n        current: value,\n      };\n    });\n  };\n\n  return [state.current, { setState, undo }];\n};\n\nconst Component = () => {\n  const [state, { setState, undo }] = useUndo("");\n\n  const handleChange = (e) => {\n    setState(e.target.value);\n  };\n\n  return (\n    <div>\n      <input type="text" onChange={handleChange} value={state} />\n      <button onClick={undo}>undo</button>\n    </div>\n  );\n};'}),(0,f.jsx)(h.P,{children:"It would be great to redo changes again. If the user undoes changes, goes in to the past, it would be great to go in to the future again to the last changes. I would encourage you to implement this feature yourself. If youre interested in seeing the end result, feel free to open the drop down."}),(0,f.jsxs)("details",{children:[(0,f.jsx)("summary",{style:{cursor:"pointer"},children:"End result"}),(0,f.jsx)(p.E,{children:'const useUndo = (initialState) => {\n  const [state, _setState] = useState({\n    past: [],\n    initialState: initialState,\n    current: initialState,\n    future: [],\n  });\n\n  const setState = (newState) => {\n    _setState((oldState) => {\n      let newPast = [];\n      if (oldState.past.length <= 10) {\n        newPast = [...oldState.past, oldState.current];\n      } else {\n        const [, /*remove first: the oldest element*/ ...rest] = oldState.past;\n        newPast = [...rest, oldState.current];\n      }\n      return {\n        ...oldState,\n        past: newPast,\n        current:\n          typeof newState === "function"\n            ? newState(oldState.current)\n            : newState,\n        future: [],\n      };\n    });\n  };\n\n  const undo = () => {\n    _setState((oldState) => {\n      if (oldState.past.length === 0) {\n        return oldState;\n      }\n      const newFuture = [...oldState.future, oldState.current];\n\n      let newPast = [...oldState.past];\n      const newState = newPast.pop();\n\n      return {\n        ...oldState,\n        past: newPast,\n        current: newState,\n        future: newFuture,\n      };\n    });\n  };\n\n  const redo = () => {\n    _setState((oldState) => {\n      if (oldState.future.length === 0) {\n        return oldState;\n      }\n      const newPast = [...oldState.past, oldState.current];\n\n      const newFuture = [...oldState.future];\n      const newState = newFuture.pop();\n\n      return {\n        ...oldState,\n        past: newPast,\n        current: newState,\n        future: newFuture,\n      };\n    });\n  };\n\n  const reset = () => {\n    _setState((oldState) => {\n      return {\n        ...oldState,\n        past: [],\n        current: state.initialState,\n        future: [],\n      };\n    });\n  };\n\n  return [\n    state.current,\n    {\n      setState,\n      undo,\n      redo,\n      reset,\n      canUndo: state.past.length > 0,\n      canRedo: state.future.length > 0,\n    },\n  ];\n};'})]})]}),title:"Undo State",copyRight:{name:"Stanislav Panchenko",email:"email@stanislavpanchenko.de"},inLanguage:"English",partfOf:"https://rilexus.github.io/advanced-react-pattern/",dataCreated:"August 19, 2022",dataPublished:"August 19, 2022",organisation:{email:"email@stanislavpanchenko.de",name:"Stanislav Panchenko",funder:{name:"Stanislav Panchenko"}},author:{url:"https://github.com/rilexus",name:"Stanislav Panchenko"}})})},x=function(){return(0,f.jsx)(j,{})}},89100:function(t,n,e){"use strict";e(67294);var a=e(85893);n.Z=function(t){var n=t.children,e=t.color;return(0,a.jsx)("div",{style:{color:e},children:n})}},13922:function(t,n,e){"use strict";e(67294);var a=e(85893);n.Z=function(t){var n=t.space,e=void 0===n?"0px":n;return(0,a.jsx)("div",{style:{paddingTop:e}})}},9771:function(t,n,e){(window.__NEXT_P=window.__NEXT_P||[]).push(["/UndoState",function(){return e(47183)}])}},function(t){t.O(0,[150,76,774,888,179],(function(){return n=9771,t(t.s=n);var n}));var n=t.O();_N_E=n}]);