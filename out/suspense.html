<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width" />
    <meta name="next-head-count" content="2" />
    <noscript data-n-css=""></noscript>
    <script
      defer=""
      nomodule=""
      src="/advanced-react-pattern/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"
    ></script>
    <script
      src="/advanced-react-pattern/_next/static/chunks/webpack-7383afc4b8866afd.js"
      defer=""
    ></script>
    <script
      src="/advanced-react-pattern/_next/static/chunks/framework-d51ece3d757c7ed2.js"
      defer=""
    ></script>
    <script
      src="/advanced-react-pattern/_next/static/chunks/main-e5ef016c3425ef5b.js"
      defer=""
    ></script>
    <script
      src="/advanced-react-pattern/_next/static/chunks/pages/_app-851a1d6d47233978.js"
      defer=""
    ></script>
    <script
      src="/advanced-react-pattern/_next/static/chunks/939-b1f31649ec1515fe.js"
      defer=""
    ></script>
    <script
      src="/advanced-react-pattern/_next/static/chunks/8782-4f6b4b88e8025081.js"
      defer=""
    ></script>
    <script
      src="/advanced-react-pattern/_next/static/chunks/pages/suspense-5461819efa9dc11b.js"
      defer=""
    ></script>
    <script
      src="/advanced-react-pattern/_next/static/tyNtCB5IEY7k43FOhVMnT/_buildManifest.js"
      defer=""
    ></script>
    <script
      src="/advanced-react-pattern/_next/static/tyNtCB5IEY7k43FOhVMnT/_ssgManifest.js"
      defer=""
    ></script>
    <script
      src="/advanced-react-pattern/_next/static/tyNtCB5IEY7k43FOhVMnT/_middlewareManifest.js"
      defer=""
    ></script>
    <style data-styled="" data-styled-version="5.3.5">
      html {
        -ms-text-size-adjust: 100%;
        -webkit-text-size-adjust: 100%;
      } /*!sc*/
      body {
        font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Oxygen,
          Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif;
        margin: 0;
        padding: 0;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
      } /*!sc*/
      data-styled.g1[id="sc-global-jbFqTx1"] {
        content: "sc-global-jbFqTx1,";
      } /*!sc*/
      .jfHJAM {
        margin-right: auto;
        margin-left: auto;
        padding-right: 15px;
        padding-left: 15px;
        width: 100%;
      } /*!sc*/
      @media screen and (max-width: 575px) {
        .jfHJAM {
          min-width: 97vw;
        }
      } /*!sc*/
      @media screen and (min-width: 576px) {
        .jfHJAM {
          max-width: 1024px;
        }
      } /*!sc*/
      data-styled.g5[id="Container__Styled-sc-zkefve-0"] {
        content: "jfHJAM,";
      } /*!sc*/
      .fHFsLe {
        white-space: nowrap;
        line-height: 1.5;
      } /*!sc*/
      data-styled.g6[id="Li__Styled-sc-2pbekf-0"] {
        content: "fHFsLe,";
      } /*!sc*/
    </style>
  </head>
  <body>
    <div id="__next">
      <div class="Container__Styled-sc-zkefve-0 jfHJAM">
        <div style="display: flex; flex-direction: row">
          <div style="margin-right: 1rem">
            <nav>
              <ul style="padding-left: 1rem">
                <li class="Li__Styled-sc-2pbekf-0 fHFsLe">
                  <a href="/advanced-react-pattern">Home</a>
                </li>
                <li class="Li__Styled-sc-2pbekf-0 fHFsLe">
                  <h4>Utils</h4>
                  <ul style="padding-left: 1rem">
                    <li class="Li__Styled-sc-2pbekf-0 fHFsLe">
                      <a href="/advanced-react-pattern/Prefetch"
                        >Prefetched State</a
                      >
                    </li>
                    <li class="Li__Styled-sc-2pbekf-0 fHFsLe">
                      <a href="/advanced-react-pattern/StateSubscription"
                        >State Subscription</a
                      >
                    </li>
                  </ul>
                </li>
                <li class="Li__Styled-sc-2pbekf-0 fHFsLe">
                  <h4>Components</h4>
                  <ul style="padding-left: 1rem">
                    <li class="Li__Styled-sc-2pbekf-0 fHFsLe">
                      <a href="/advanced-react-pattern/suspense">Suspense</a>
                    </li>
                    <li class="Li__Styled-sc-2pbekf-0 fHFsLe">
                      <a href="/advanced-react-pattern/CompoundToggle"
                        >Compound Components</a
                      >
                    </li>
                    <li class="Li__Styled-sc-2pbekf-0 fHFsLe">
                      <a href="/advanced-react-pattern/StateReducer"
                        >State Reducer</a
                      >
                    </li>
                    <li class="Li__Styled-sc-2pbekf-0 fHFsLe">
                      <a href="/advanced-react-pattern/PropCollection"
                        >Props Collection</a
                      >
                    </li>
                    <li class="Li__Styled-sc-2pbekf-0 fHFsLe">
                      <a href="/advanced-react-pattern/RenderPropsToggle"
                        >Render Props</a
                      >
                    </li>
                    <li class="Li__Styled-sc-2pbekf-0 fHFsLe">
                      <a href="/advanced-react-pattern/Factory">Factory</a>
                    </li>
                    <li class="Li__Styled-sc-2pbekf-0 fHFsLe">
                      <a href="/advanced-react-pattern/ControlProps"
                        >Control Props</a
                      >
                    </li>
                    <li class="Li__Styled-sc-2pbekf-0 fHFsLe">
                      <a href="/advanced-react-pattern/Decorator">Decorator</a>
                    </li>
                  </ul>
                </li>
                <li class="Li__Styled-sc-2pbekf-0 fHFsLe">
                  <h4>Hooks</h4>
                  <ul style="padding-left: 1rem">
                    <li class="Li__Styled-sc-2pbekf-0 fHFsLe">
                      <a href="/advanced-react-pattern/ThunkReducer"
                        >Thunk Reducer</a
                      >
                    </li>
                    <li class="Li__Styled-sc-2pbekf-0 fHFsLe">
                      <a href="/advanced-react-pattern/ReducerHook"
                        >Reducer Hook</a
                      >
                    </li>
                  </ul>
                </li>
              </ul>
            </nav>
          </div>
          <div>
            <main>
              <article>
                <header>
                  <h1 style="font-size: 2rem">Suspense</h1>
                  <div>
                    <address>
                      By<!-- -->
                      <a rel="author" href="https://github.com/rilexus"
                        >Stanislav Panchenko</a
                      >
                    </address>
                    on<!-- -->
                    <time datetime="2022-06-19" title="Jun 19th, 2022"
                      >6/19/22</time
                    >
                  </div>
                </header>
                <p
                  style="line-height: 1.4; font-size: 1.125rem; color: #1a1a1a"
                >
                  <i
                    >After this article you should be able to understand what
                    lazy loading is, why it maters and how it is implemented
                    under the hood.</i
                  >
                </p>
                <p
                  style="line-height: 1.4; font-size: 1.125rem; color: #1a1a1a"
                >
                  Imagine you have a big Single Page Application with a sidebar
                  like this one.
                </p>
                <figure>
                  <img
                    width="500px"
                    height="auto"
                    src="/advanced-react-pattern/application_sidebar.png"
                  />
                  <figcaption>Screenshot of the JIRA application.</figcaption>
                </figure>
                <p
                  style="line-height: 1.4; font-size: 1.125rem; color: #1a1a1a"
                >
                  Every button lead to a different page. I think the word
                  &quot;view&quot; would be more appropriate, since its not a
                  page. So every view is separate and independent from each
                  other. It has its own purpose, its own code.
                </p>
                <p
                  style="line-height: 1.4; font-size: 1.125rem; color: #1a1a1a"
                >
                  The user is interested in one view at a time and probably he
                  is not interested in all the views of the application. Just
                  think how often you visit the &quot;setting&quot; view of any
                  application. I bet, you go there one time a month, if at all.
                </p>
                <p
                  style="line-height: 1.4; font-size: 1.125rem; color: #1a1a1a"
                >
                  Now the thing is, if we as a developer do not pay attention,
                  we would bundle the whole application to one single file. We
                  will have one HTML file with a single div in it, where the
                  application is going to be mounted and a javascript file which
                  contains the application.
                </p>
                <p
                  style="line-height: 1.4; font-size: 1.125rem; color: #1a1a1a"
                >
                  This has an effect on the loading time ouf the application and
                  the user experience. Just think about it! How much code does
                  the application in total has? How many css lines, images,
                  svg`s etc. We ship a lot of code and in our current case, we
                  shit a lot of code at once.
                </p>
                <p
                  style="line-height: 1.4; font-size: 1.125rem; color: #1a1a1a"
                >
                  Luckily we can improve this by utilising<!-- -->
                  <a href="https://webpack.js.org/guides/lazy-loading/"
                    >webpack and the import function.</a
                  >
                </p>
                <div style="margin: 1rem 0; font-size: 0.9rem">
                  <span
                    style="
                      font-size: inherit;
                      font-family: inherit;
                      background: #f3f3f3;
                      color: #25282a;
                      border-radius: 3px;
                      display: flex;
                      line-height: 1.4285714285714286;
                      overflow-x: auto;
                      white-space: pre;
                    "
                    ><code
                      style="
                        font-size: inherit;
                        font-family: inherit;
                        line-height: 1.6666666666666667;
                        padding: 8px;
                      "
                      >const Backlog = await import(/* webpackChunkName:
                      &quot;Backlog&quot; */ &quot;../Backlog&quot;); const
                      Board = await import(/* webpackChunkName:
                      &quot;Board&quot; */&quot;../Board&quot;); const Reports =
                      await import(/* webpackChunkName: &quot;Report&quot;
                      */&quot;../Reports&quot;); const Releases = await
                      import(/* webpackChunkName: &quot;Releases&quot;
                      */&quot;../Releases&quot;);</code
                    ></span
                  >
                </div>
                <p
                  style="line-height: 1.4; font-size: 1.125rem; color: #1a1a1a"
                >
                  By doing this, webpack will split our application during the
                  bundle time in small chunks. We will not get one single, heavy
                  file, but multiple small once. One file for every component.
                </p>
                <p
                  style="line-height: 1.4; font-size: 1.125rem; color: #1a1a1a"
                >
                  There is one thing left to do for us. That is to load this js
                  files and to display those components only when we need them.
                </p>
                <p
                  style="line-height: 1.4; font-size: 1.125rem; color: #1a1a1a"
                >
                  One obvious implementation could be like this.
                </p>
                <div style="margin: 1rem 0; font-size: 0.9rem">
                  <span
                    style="
                      font-size: inherit;
                      font-family: inherit;
                      background: #f3f3f3;
                      color: #25282a;
                      border-radius: 3px;
                      display: flex;
                      line-height: 1.4285714285714286;
                      overflow-x: auto;
                      white-space: pre;
                    "
                    ><code
                      style="
                        font-size: inherit;
                        font-family: inherit;
                        line-height: 1.6666666666666667;
                        padding: 8px;
                      "
                      >const Component = () =&gt; { const [, rerender] =
                      useToggle(); const backlogRef = useRef(null); const
                      loadSidebar = async () =&gt; { //if backlog already
                      loaded, do nothing if (backlogRef.current) return; const {
                      default: Component } = await import(/* webpackChunkName:
                      &quot;Backlog&quot; */ &quot;../Backlog&quot;);
                      backlogRef.current = Component; rerender(); }; const
                      Backlog = backlogRef.current; return ( &lt;div&gt;
                      &lt;div&gt; {/*sidebar*/} &lt;button
                      onClick={loadSidebar}&gt;Backlog&lt;/button&gt;
                      &lt;/div&gt; &lt;div&gt; {/*view*/} {Backlog &amp;&amp;
                      &lt;Backlog /&gt;} &lt;/div&gt; &lt;/div&gt; ); };</code
                    ></span
                  >
                </div>
                <p
                  style="line-height: 1.4; font-size: 1.125rem; color: #1a1a1a"
                >
                  We import the component on click, await the data, save it in a
                  ref, rerender and were done.
                </p>
                <p
                  style="line-height: 1.4; font-size: 1.125rem; color: #1a1a1a"
                >
                  That works great! Although it is manuel work and very verbose.
                  For every view, we would need to write the same logic again
                  and again. I personally would prefer not to think about the
                  implementation at all. I would like to simply use it. I would
                  like to have it more like: &quot;Here is a component. Please
                  load and display it only as soon as I need it.&quot;
                </p>
                <div style="margin: 1rem 0; font-size: 0.9rem">
                  <span
                    style="
                      font-size: inherit;
                      font-family: inherit;
                      background: #f3f3f3;
                      color: #25282a;
                      border-radius: 3px;
                      display: flex;
                      line-height: 1.4285714285714286;
                      overflow-x: auto;
                      white-space: pre;
                    "
                    ><code
                      style="
                        font-size: inherit;
                        font-family: inherit;
                        line-height: 1.6666666666666667;
                        padding: 8px;
                      "
                      >const Backlog = (props) =&gt; { const [, rerender] =
                      useToggle(); const ref = useRef(() =&gt; null);
                      useEffect(() =&gt; {
                      import(&#x27;../Backlog&#x27;).then(({default: Component})
                      =&gt; { ref.current = Component; rerender() }); }, []);
                      const Component = ref.current; return &lt;Component
                      {...props}/&gt; }</code
                    ></span
                  >
                </div>
                <p
                  style="line-height: 1.4; font-size: 1.125rem; color: #1a1a1a"
                >
                  This is much better! Every component would be isolated. I can
                  simply import it and use it. Personally, I would not prefer to
                  write this for every component tho.
                </p>
                <p
                  style="line-height: 1.4; font-size: 1.125rem; color: #1a1a1a"
                >
                  Lets move out the import state.
                </p>
                <div style="margin: 1rem 0; font-size: 0.9rem">
                  <span
                    style="
                      font-size: inherit;
                      font-family: inherit;
                      background: #f3f3f3;
                      color: #25282a;
                      border-radius: 3px;
                      display: flex;
                      line-height: 1.4285714285714286;
                      overflow-x: auto;
                      white-space: pre;
                    "
                    ><code
                      style="
                        font-size: inherit;
                        font-family: inherit;
                        line-height: 1.6666666666666667;
                        padding: 8px;
                      "
                      >const Lazy = ({ factory,...props }) =&gt; { const [,
                      rerender] = useToggle(); const ref = useRef(null);
                      useEffect(() =&gt; { factory().then(({ default: Component
                      }) =&gt; { ref.current = Component; rerender(); }); },
                      []); const Component = ref.current; return Component
                      &amp;&amp; &lt;Component {...props} /&gt;; }; const
                      Backlog = (props) =&gt; { return &lt;Lazy factory={()
                      =&gt; import(&#x27;../Backlog&#x27;)} {...props}/&gt;
                      }</code
                    ></span
                  >
                </div>
                <p
                  style="line-height: 1.4; font-size: 1.125rem; color: #1a1a1a"
                >
                  Instead of hard code the import, we delegate the import call
                  to a function. Now I do not need to reimplement the same logic
                  multiple times. This solution is definitely better then the
                  thing we have started with. Still to much work for me tho. I
                  do not like to worry about the props spreading, passing the
                  import statement in to a component, wrap it in another
                  component. Hustle! All this should be automated even further.
                </p>
                <p
                  style="line-height: 1.4; font-size: 1.125rem; color: #1a1a1a"
                >
                  Something like this would be awesome!
                </p>
                <div style="margin: 1rem 0; font-size: 0.9rem">
                  <span
                    style="
                      font-size: inherit;
                      font-family: inherit;
                      background: #f3f3f3;
                      color: #25282a;
                      border-radius: 3px;
                      display: flex;
                      line-height: 1.4285714285714286;
                      overflow-x: auto;
                      white-space: pre;
                    "
                    ><code
                      style="
                        font-size: inherit;
                        font-family: inherit;
                        line-height: 1.6666666666666667;
                        padding: 8px;
                      "
                      >const BackLog = lazy(() =&gt;
                      import(&quot;../Backlog&quot;));</code
                    ></span
                  >
                </div>
                <p
                  style="line-height: 1.4; font-size: 1.125rem; color: #1a1a1a"
                >
                  I get a component back, the import is delegated and I should
                  not worry about props.
                </p>
                <div style="margin: 1rem 0; font-size: 0.9rem">
                  <span
                    style="
                      font-size: inherit;
                      font-family: inherit;
                      background: #f3f3f3;
                      color: #25282a;
                      border-radius: 3px;
                      display: flex;
                      line-height: 1.4285714285714286;
                      overflow-x: auto;
                      white-space: pre;
                    "
                    ><code
                      style="
                        font-size: inherit;
                        font-family: inherit;
                        line-height: 1.6666666666666667;
                        padding: 8px;
                      "
                      >const lazy = (factory) =&gt; { // return a React
                      component function return function LazyWrapper(props) {
                      const [, rerender] = useToggle(); const ref = useRef(()
                      =&gt; null); useEffect(() =&gt; { // load JS module right
                      away, LazyWrapper lazy is called factory() // wait for the
                      JS module to be resolved .then(({ default: Component })
                      =&gt; { ref.current = Component; rerender(); }) .catch((e)
                      =&gt; { // handle error }); }, []); const Component =
                      ref.current; return &lt;Component {...props} /&gt;; };
                      };</code
                    ></span
                  >
                </div>
                <p
                  style="line-height: 1.4; font-size: 1.125rem; color: #1a1a1a"
                >
                  That is much better!
                </p>
                <p
                  style="line-height: 1.4; font-size: 1.125rem; color: #1a1a1a"
                >
                  I would import all needed components at the top of the file
                  and not worry about re-rendering, refs props and so on.
                </p>
                <div style="margin: 1rem 0; font-size: 0.9rem">
                  <span
                    style="
                      font-size: inherit;
                      font-family: inherit;
                      background: #f3f3f3;
                      color: #25282a;
                      border-radius: 3px;
                      display: flex;
                      line-height: 1.4285714285714286;
                      overflow-x: auto;
                      white-space: pre;
                    "
                    ><code
                      style="
                        font-size: inherit;
                        font-family: inherit;
                        line-height: 1.6666666666666667;
                        padding: 8px;
                      "
                      >const Backlog = lazy(() =&gt; import(/* webpackChunkName:
                      &quot;Backlog&quot; */ &quot;../Backlog&quot;)); const
                      Board = lazy(() =&gt; import(/* webpackChunkName:
                      &quot;Board&quot; */&quot;../Board&quot;)); const Reports
                      = lazy(() =&gt; import(/* webpackChunkName:
                      &quot;Report&quot; */&quot;../Reports&quot;));</code
                    ></span
                  >
                </div>
                <p
                  style="line-height: 1.4; font-size: 1.125rem; color: #1a1a1a"
                >
                  The application would look this now.
                </p>
                <div style="margin: 1rem 0; font-size: 0.9rem">
                  <span
                    style="
                      font-size: inherit;
                      font-family: inherit;
                      background: #f3f3f3;
                      color: #25282a;
                      border-radius: 3px;
                      display: flex;
                      line-height: 1.4285714285714286;
                      overflow-x: auto;
                      white-space: pre;
                    "
                    ><code
                      style="
                        font-size: inherit;
                        font-family: inherit;
                        line-height: 1.6666666666666667;
                        padding: 8px;
                      "
                      >const Application = () =&gt; { const [currentComponent,
                      setComponent] = useState(&quot;Backlog&quot;); return (
                      &lt;div&gt; &lt;div&gt; &lt;button onClick={() =&gt;
                      setComponent(&quot;Backlog&quot;)}&gt;Backlog&lt;/button&gt;
                      &lt;button onClick={() =&gt;
                      setComponent(&quot;Board&quot;)}&gt;Board&lt;/button&gt;
                      &lt;button onClick={() =&gt;
                      setComponent(&quot;Report&quot;)}&gt;Report&lt;/button&gt;
                      &lt;/div&gt; &lt;div&gt; {currentComponent ===
                      &#x27;Backlog&#x27; &amp;&amp; &lt;Backlog/&gt;}
                      {currentComponent === &#x27;Board&#x27; &amp;&amp;
                      &lt;Board/&gt;} {currentComponent === &#x27;Report&#x27;
                      &amp;&amp; &lt;Report/&gt;} &lt;/div&gt; &lt;/div&gt; );
                      };</code
                    ></span
                  >
                </div>
                <small
                  >You could you the react-router when you prefer that.</small
                >
                <p
                  style="line-height: 1.4; font-size: 1.125rem; color: #1a1a1a"
                >
                  This is nice and neat! And the best part is, that the
                  application will be served to the user much faster.
                </p>
                <p
                  style="line-height: 1.4; font-size: 1.125rem; color: #1a1a1a"
                >
                  The behavior of the application would be now like this:
                </p>
                <div>
                  <div style="border: 1px solid black; display: flex">
                    <div
                      style="
                        margin-right: 1rem;
                        padding-right: 1rem;
                        border: 1px solid grey;
                      "
                    >
                      <i>Sidebar</i>
                      <div><button>Backlog</button></div>
                      <div><button>Board</button></div>
                      <div><button>Release</button></div>
                    </div>
                    <div>
                      <i>View</i>
                      <div style="height: 15rem"></div>
                    </div>
                  </div>
                </div>
                <p
                  style="line-height: 1.4; font-size: 1.125rem; color: #1a1a1a"
                >
                  If you open the network tab in the browser, every time you
                  click on the sidebar button, you will see that the component
                  file is being loaded. The application is not served as a whole
                  initially, but piece by piece.
                </p>
                <figure>
                  <img
                    src="/advanced-react-pattern/watterfall.png"
                    alt=""
                    width="600px"
                  />
                  <figcaption>Browsers network tab.</figcaption>
                </figure>
                <p
                  style="line-height: 1.4; font-size: 1.125rem; color: #1a1a1a"
                >
                  Currently we have an UX issue. When you click the sidebar
                  button, the current view disappears and the user sees nothing
                  for one second. In the real life application it might be
                  longer or shorter depending on the size of the component file
                  and the internet connect of the user. In the current example
                  its 1000ms exactly, because I have delayed the response time
                  to illustrate the issue.
                </p>
                <p
                  style="line-height: 1.4; font-size: 1.125rem; color: #1a1a1a"
                >
                  Leaving the user with a blank page is disorienting. Lets fix
                  that. We could do something like this:
                </p>
                <div style="margin: 1rem 0; font-size: 0.9rem">
                  <span
                    style="
                      font-size: inherit;
                      font-family: inherit;
                      background: #f3f3f3;
                      color: #25282a;
                      border-radius: 3px;
                      display: flex;
                      line-height: 1.4285714285714286;
                      overflow-x: auto;
                      white-space: pre;
                    "
                    ><code
                      style="
                        font-size: inherit;
                        font-family: inherit;
                        line-height: 1.6666666666666667;
                        padding: 8px;
                      "
                      >const BackLog = lazy(() =&gt;
                      import(&quot;../Backlog&quot;)); const Component = ()
                      =&gt; { return &lt;BackLog
                      fallback={&lt;div&gt;Loading...&lt;/div&gt;}/&gt; }</code
                    ></span
                  >
                </div>
                <p
                  style="line-height: 1.4; font-size: 1.125rem; color: #1a1a1a"
                >
                  We pass a fallback UI element. While the component is being
                  served, a fallback should be displayed. <br />We could
                  implement that, but Im not a fan of this solution. It would
                  suggest that the Backlog component itself accepts a fallback.
                  But it does not! The fallback is not an implementation detail
                  for the Backlog.
                </p>
                <p
                  style="line-height: 1.4; font-size: 1.125rem; color: #1a1a1a"
                >
                  I would be nice to do something like this instead:
                </p>
                <div style="margin: 1rem 0; font-size: 0.9rem">
                  <span
                    style="
                      font-size: inherit;
                      font-family: inherit;
                      background: #f3f3f3;
                      color: #25282a;
                      border-radius: 3px;
                      display: flex;
                      line-height: 1.4285714285714286;
                      overflow-x: auto;
                      white-space: pre;
                    "
                    ><code
                      style="
                        font-size: inherit;
                        font-family: inherit;
                        line-height: 1.6666666666666667;
                        padding: 8px;
                      "
                      >const BackLog = lazy(() =&gt;
                      import(&quot;../Backlog&quot;)); const Component = ()
                      =&gt; { return ( &lt;Suspence
                      fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt;
                      &lt;BackLog /&gt; &lt;/Suspence&gt; ); };</code
                    ></span
                  >
                </div>
                <p
                  style="line-height: 1.4; font-size: 1.125rem; color: #1a1a1a"
                >
                  Currently there is no way I could do that. The Suspense
                  component does not communicate with the Backlog in any way. We
                  could solve it with the -as I call it-<!-- -->
                  <a href="/advanced-react-pattern/Decorator">Decorator</a>
                  pattern. I would pass a callback to the Backlog and as soon as
                  the component finishes loading call it and rerender the
                  Suspense component.
                </p>
                <p
                  style="line-height: 1.4; font-size: 1.125rem; color: #1a1a1a"
                >
                  There is another way tho! This will conclude this article.
                </p>
                <p
                  style="line-height: 1.4; font-size: 1.125rem; color: #1a1a1a"
                >
                  Lets adjust the lazy function:
                </p>
                <div style="margin: 1rem 0; font-size: 0.9rem">
                  <span
                    style="
                      font-size: inherit;
                      font-family: inherit;
                      background: #f3f3f3;
                      color: #25282a;
                      border-radius: 3px;
                      display: flex;
                      line-height: 1.4285714285714286;
                      overflow-x: auto;
                      white-space: pre;
                    "
                    ><code
                      style="
                        font-size: inherit;
                        font-family: inherit;
                        line-height: 1.6666666666666667;
                        padding: 8px;
                      "
                      >const lazy = (factory) =&gt; { let Component = () =&gt;
                      null; let status = &quot;pending&quot;; // return a React
                      component function return function LazyWrapper(props) {
                      useEffect(() =&gt; { // load JS module right away,
                      LazyWrapper lazy is called let promise = factory() // wait
                      for the JS module to be resolved .then((module) =&gt; {
                      status = &quot;resolved&quot;; // get the default export
                      from a file Component = module.default; }) .catch((e)
                      =&gt; { // handle error status = &quot;error&quot;; }); //
                      if still pending, throw to by catched by Suspense if
                      (status === &quot;pending&quot;) { throw promise; } },
                      []); return &lt;Component {...props} /&gt;; }; };</code
                    ></span
                  >
                </div>
                <p
                  style="line-height: 1.4; font-size: 1.125rem; color: #1a1a1a"
                >
                  As soon as the LazyWrapper renders, the factory is called and
                  as long as the promise is pending, we throw it. Yes, we can
                  throw a promise. We can throw not only error instances, we can
                  throw anything. String, numbers, you name it! You can throw
                  even functions.
                </p>
                <figure>
                  <img
                    src="https://media.giphy.com/media/l4FGCfEWJ7ztMzZao/giphy.gif"
                    alt="Facial expression emphasizing confusion."
                  />
                </figure>
                <p
                  style="line-height: 1.4; font-size: 1.125rem; color: #1a1a1a"
                >
                  The implementation of the Suspense looks like this:
                </p>
                <div style="margin: 1rem 0; font-size: 0.9rem">
                  <span
                    style="
                      font-size: inherit;
                      font-family: inherit;
                      background: #f3f3f3;
                      color: #25282a;
                      border-radius: 3px;
                      display: flex;
                      line-height: 1.4285714285714286;
                      overflow-x: auto;
                      white-space: pre;
                    "
                    ><code
                      style="
                        font-size: inherit;
                        font-family: inherit;
                        line-height: 1.6666666666666667;
                        padding: 8px;
                      "
                      >class Suspense extends React.Component {
                      constructor(props) { super(props); this.state = {
                      isLoading: false }; } componentDidCatch(promiseOrError,
                      errorInfo) { // do nothing, if not a promise if (typeof
                      promiseOrError.then !== &quot;function&quot;) return;
                      const promise = promiseOrError; this.setState({ // if
                      catched, show fallback isLoading: true, }); promise
                      .then(() =&gt; { // promise is resolved, render children
                      this.setState({ isLoading: false, }); }) .catch((e) =&gt;
                      { // handle error }); } render() { const { isLoading } =
                      this.state; const { fallback, children } = this.props; if
                      (isLoading) { return fallback; } return children; }
                      }</code
                    ></span
                  >
                </div>
                <p
                  style="line-height: 1.4; font-size: 1.125rem; color: #1a1a1a"
                >
                  The steps of the execution are as follows: Suspense renders
                  children, the LazyWrapper from the lazy functions renders and
                  throws the promise, Suspense catches it in the
                  componentDidCatch function, it sets the internal state to
                  isLoading, re-renders and shows the fallback UI. As soon as
                  the promise resolves, Suspense sets the isLoading state to
                  false and renders children again. This time the LazyWrapper
                  does not call the factory but renders the fetched component.
                </p>
              </article>
            </main>
          </div>
        </div>
      </div>
    </div>
    <script id="__NEXT_DATA__" type="application/json">
      {
        "props": { "pageProps": {} },
        "page": "/suspense",
        "query": {},
        "buildId": "tyNtCB5IEY7k43FOhVMnT",
        "assetPrefix": "/advanced-react-pattern",
        "nextExport": true,
        "autoExport": true,
        "isFallback": false,
        "scriptLoader": []
      }
    </script>
  </body>
</html>
