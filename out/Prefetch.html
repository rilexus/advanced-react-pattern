<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/advanced-react-pattern/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/advanced-react-pattern/_next/static/chunks/webpack-1114306cd7089e72.js" defer=""></script><script src="/advanced-react-pattern/_next/static/chunks/framework-d51ece3d757c7ed2.js" defer=""></script><script src="/advanced-react-pattern/_next/static/chunks/main-e5ef016c3425ef5b.js" defer=""></script><script src="/advanced-react-pattern/_next/static/chunks/pages/_app-8c5bff8b4ce56d50.js" defer=""></script><script src="/advanced-react-pattern/_next/static/chunks/939-b1f31649ec1515fe.js" defer=""></script><script src="/advanced-react-pattern/_next/static/chunks/7952-384e36bf38684cb1.js" defer=""></script><script src="/advanced-react-pattern/_next/static/chunks/pages/Prefetch-9c0c4e85f5c18d8e.js" defer=""></script><script src="/advanced-react-pattern/_next/static/ERDtAF2AnkiOE8NbNtW-f/_buildManifest.js" defer=""></script><script src="/advanced-react-pattern/_next/static/ERDtAF2AnkiOE8NbNtW-f/_ssgManifest.js" defer=""></script><script src="/advanced-react-pattern/_next/static/ERDtAF2AnkiOE8NbNtW-f/_middlewareManifest.js" defer=""></script><style data-styled="" data-styled-version="5.3.5">html{-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%;}/*!sc*/
body{font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;margin:0;padding:0;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;}/*!sc*/
data-styled.g1[id="sc-global-jbFqTx1"]{content:"sc-global-jbFqTx1,"}/*!sc*/
.jfHJAM{margin-right:auto;margin-left:auto;padding-right:15px;padding-left:15px;width:100%;}/*!sc*/
@media screen and (max-width:575px){.jfHJAM{min-width:97vw;}}/*!sc*/
@media screen and (min-width:576px){.jfHJAM{max-width:1024px;}}/*!sc*/
data-styled.g5[id="Container__Styled-sc-zkefve-0"]{content:"jfHJAM,"}/*!sc*/
.fHFsLe{white-space:nowrap;line-height:1.5;}/*!sc*/
data-styled.g6[id="Li__Styled-sc-2pbekf-0"]{content:"fHFsLe,"}/*!sc*/
</style></head><body><div id="__next"><div class="Container__Styled-sc-zkefve-0 jfHJAM"><div style="display:flex;flex-direction:row"><div style="margin-right:1rem"><nav><ul style="padding-left:1rem"><li class="Li__Styled-sc-2pbekf-0 fHFsLe"><a href="/advanced-react-pattern">Home</a></li><li class="Li__Styled-sc-2pbekf-0 fHFsLe"><h4>Utils</h4><ul style="padding-left:1rem"><li class="Li__Styled-sc-2pbekf-0 fHFsLe"><a href="/advanced-react-pattern/Prefetch">Prefetched State</a></li><li class="Li__Styled-sc-2pbekf-0 fHFsLe"><a href="/advanced-react-pattern/StateSubscription">State Subscription</a></li></ul></li><li class="Li__Styled-sc-2pbekf-0 fHFsLe"><h4>Components</h4><ul style="padding-left:1rem"><li class="Li__Styled-sc-2pbekf-0 fHFsLe"><a href="/advanced-react-pattern/CompoundToggle">Compound Components</a></li><li class="Li__Styled-sc-2pbekf-0 fHFsLe"><a href="/advanced-react-pattern/StateReducer">State Reducer</a></li><li class="Li__Styled-sc-2pbekf-0 fHFsLe"><a href="/advanced-react-pattern/PropCollection">Props Collection</a></li><li class="Li__Styled-sc-2pbekf-0 fHFsLe"><a href="/advanced-react-pattern/RenderPropsToggle">Render Props</a></li><li class="Li__Styled-sc-2pbekf-0 fHFsLe"><a href="/advanced-react-pattern/Factory">Factory</a></li><li class="Li__Styled-sc-2pbekf-0 fHFsLe"><a href="/advanced-react-pattern/ControlProps">Control Props</a></li><li class="Li__Styled-sc-2pbekf-0 fHFsLe"><a href="/advanced-react-pattern/Decorator">Decorator</a></li></ul></li><li class="Li__Styled-sc-2pbekf-0 fHFsLe"><h4>Hooks</h4><ul style="padding-left:1rem"><li class="Li__Styled-sc-2pbekf-0 fHFsLe"><a href="/advanced-react-pattern/ThunkReducer">Thunk Reducer</a></li><li class="Li__Styled-sc-2pbekf-0 fHFsLe"><a href="/advanced-react-pattern/ReducerHook">Reducer Hook</a></li></ul></li></ul></nav></div><main><article><div><h1 style="font-size:2rem">Prefetch</h1><p style="line-height:1.4;font-size:1.125rem;color:#1a1a1a">Fetching data in React usually looks like this:</p><figure><div style="margin:1rem 0;font-size:.9rem"><span style="font-size:inherit;font-family:inherit;background:#f3f3f3;color:#25282a;border-radius:3px;display:flex;line-height:1.4285714285714286;overflow-x:auto;white-space:pre"><code style="font-size:inherit;font-family:inherit;line-height:1.6666666666666667;padding:8px">const Component = () =&gt; {
  const [data, setData] = useState(null);

  useEffect(() =&gt; {
    // fetch as soon as component mounts
    fetchData().then((d) =&gt; {
      setData(d);
    });
  }, []);

  return data &amp;&amp; &lt;div&gt;children&lt;/div&gt;;
};</code></span></div></figure><p style="line-height:1.4;font-size:1.125rem;color:#1a1a1a">You fetch as soon as the component mounts. While the data is on the way, you postpone the rendering of children. This way of getting data does not do any harm in the majority of cases. It has one fault tho. Its the fetching on mount. To make make case clear, Ill provide couple of examples.</p><p style="line-height:1.4;font-size:1.125rem;color:#1a1a1a">ADD TEXT</p><figure><div style="margin:1rem 0;font-size:.9rem"><span style="font-size:inherit;font-family:inherit;background:#f3f3f3;color:#25282a;border-radius:3px;display:flex;line-height:1.4285714285714286;overflow-x:auto;white-space:pre"><code style="font-size:inherit;font-family:inherit;line-height:1.6666666666666667;padding:8px">const Component = () =&gt; {
  return (
    &lt;div&gt;
      &lt;ComponentA&gt;
        &lt;ComponentB&gt;
          &lt;ComponentC&gt;
            &lt;ComponentD /&gt;
          &lt;/ComponentC&gt;
        &lt;/ComponentB&gt;
      &lt;/ComponentA&gt;
    &lt;/div&gt;
  );
};</code></span></div></figure><figure><div><div style="height:26rem;border:1px solid black"><div>Component A</div><div>Data: </div><div style="padding:2rem"><div>Loading...</div></div></div></div></figure><p style="line-height:1.4;font-size:1.125rem;color:#1a1a1a">One thing they have certainly in common. They render its children as soon as the data is available. The difference is that the sequence example fetches, as the naming suggest, in sequence: on mount, while the parallel example fetches all needed data parallel, even before react starts rendering anything.</p><p style="line-height:1.4;font-size:1.125rem;color:#1a1a1a">The implementation of the sequence components looks like this:</p><figure><div style="margin:1rem 0;font-size:.9rem"><span style="font-size:inherit;font-family:inherit;background:#f3f3f3;color:#25282a;border-radius:3px;display:flex;line-height:1.4285714285714286;overflow-x:auto;white-space:pre"><code style="font-size:inherit;font-family:inherit;line-height:1.6666666666666667;padding:8px">const ComponentA = ({ children }) =&gt; {
  const [data, setData] = useState(null);

  useEffect(() =&gt; {
    fetchData().then((d) =&gt; {
      setData(d);
    });
  }, []);

  return (
    &lt;div
      style={{
        height: &quot;34rem&quot;,
        border: &quot;1px solid black&quot;,
      }}
    &gt;
      &lt;div&gt;Component A&lt;/div&gt;
      &lt;div&gt;Data: {data &amp;&amp; JSON.stringify(data)}&lt;/div&gt;
      &lt;div style={{ padding: &quot;3rem&quot; }}&gt;
        {!data ? &lt;div&gt;Loading...&lt;/div&gt; : &lt;div&gt;{children}&lt;/div&gt;}
      &lt;/div&gt;
    &lt;/div&gt;
  );
};</code></span></div></figure><p style="line-height:1.4;font-size:1.125rem;color:#1a1a1a">And the implementation of the parallel component looks like this:</p><figure><div style="margin:1rem 0;font-size:.9rem"><span style="font-size:inherit;font-family:inherit;background:#f3f3f3;color:#25282a;border-radius:3px;display:flex;line-height:1.4285714285714286;overflow-x:auto;white-space:pre"><code style="font-size:inherit;font-family:inherit;line-height:1.6666666666666667;padding:8px">const useData = prefetch(
  async () =&gt; fetchData()
);

const ComponentA = ({ children }) =&gt; {
  const [data] = useData();

  return (
    &lt;div
      style={{
        height: &quot;34rem&quot;,
        border: &quot;1px solid black&quot;,
      }}
    &gt;
      &lt;div&gt;Component A&lt;/div&gt;
      &lt;div&gt;Data: {data &amp;&amp; JSON.stringify(data)}&lt;/div&gt;
      &lt;div style={{ padding: &quot;3rem&quot; }}&gt;
        {!data ? &lt;div&gt;Loading...&lt;/div&gt; : &lt;div&gt;{children}&lt;/div&gt;}
      &lt;/div&gt;
    &lt;/div&gt;
  );
};</code></span></div></figure><p style="line-height:1.4;font-size:1.125rem;color:#1a1a1a">If we run them side by side, the difference is pretty clear.</p></div><figure><figcaption>Sequence fetch (Waterfall)</figcaption><div><div style="height:26rem;border:1px solid black"><div>Component A</div><div>Data: </div><div style="padding:2rem"><div>Loading...</div></div></div></div></figure><figure><figcaption>Parallel Fetch</figcaption><div><div style="height:26rem;border:1px solid black"><div>Component A</div><div>Data: </div><div style="padding:2rem"><div>Loading...</div></div></div></div></figure><p style="line-height:1.4;font-size:1.125rem;color:#1a1a1a">The parallel fetching is always faster. If you need to fetch data on mount, I would suggest you not to do that. Prefetch the data and rerender as soon as data is available.</p><p style="line-height:1.4;font-size:1.125rem;color:#1a1a1a">A simple implementation of the &quot;prefetch&quot; function is below. Error handling is omitted here.</p><figure><div style="margin:1rem 0;font-size:.9rem"><span style="font-size:inherit;font-family:inherit;background:#f3f3f3;color:#25282a;border-radius:3px;display:flex;line-height:1.4285714285714286;overflow-x:auto;white-space:pre"><code style="font-size:inherit;font-family:inherit;line-height:1.6666666666666667;padding:8px">function prefetch(resolver) {
  const ERROR = &quot;error&quot;;
  const RESOLVED = &quot;resolved&quot;;
  const FETCHING = &quot;fetching&quot;;

  let status = FETCHING; // initial status
  let result = null;
  let error = null;

  const promised = resolver();
  // subscribe to the promise as soon as this function is called
  promised.then(
    (_data) =&gt; {
      status = RESOLVED;
      result = _data;
    },
    (_error) =&gt; {
      status = ERROR;
      error = _error;
    }
  );

  return () =&gt; {
    // return a hook function
    const rerender = useRerender();

    useEffect(() =&gt; {
      if (status === FETCHING) {
        // if this hook renders before the promise is resolved
        promised.then(() =&gt; {
          // await the result, rerender the component
          rerender();
        });
      }
    }, []);

    return [result, error];
  };
}</code></span></div></figure></article></main></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{}},"page":"/Prefetch","query":{},"buildId":"ERDtAF2AnkiOE8NbNtW-f","assetPrefix":"/advanced-react-pattern","nextExport":true,"autoExport":true,"isFallback":false,"scriptLoader":[]}</script></body></html>