(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[569],{5673:function(n,e,t){"use strict";t.r(e);t(7794),t(7294);var a=t(8556),s=t(4663),o=t(3236),r=t(3208),i=t(5234),d=t(5893);e.default=function(){return(0,d.jsx)(i.Z,{children:(0,d.jsx)("div",{children:(0,d.jsxs)(r.Z,{children:[(0,d.jsx)(r.Z.Headline,{children:(0,d.jsx)(a.Z,{children:"The useFetch hook"})}),(0,d.jsx)(r.Z.Author,{name:"Stanislav Panchenko",url:"https://github.com/rilexus"}),(0,d.jsx)(r.Z.DatePublished,{children:"August 19, 2022"}),(0,d.jsx)(r.Z.Body,{style:{marginBottom:"2rem"},children:(0,d.jsxs)("div",{children:[(0,d.jsx)(s.P,{children:"Fetching data from an endpoint on mount is a long tradition in react. Most of the time it looks like this:"}),(0,d.jsx)(o.E,{children:'const Component = () => {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    setLoading(true);\n    fetch("api/data", {})\n      .then((data) => {\n        setData(data);\n        setLoading(false);\n      })\n      .catch((e) => {\n        setError(e);\n      });\n  }, []);\n\n  return <div>{!loading ? <div>{data}</div> : null}</div>;\n};'}),(0,d.jsx)(s.P,{children:"We handle 3 states a once for one fetch operation: one for the data, one for the loading state and one for the error. Here we postpone rendering as long as the loading state is true."}),(0,d.jsx)(s.P,{children:"This pattern is often times repeated though out the application again and again. That should not be the case, especially because this pattern is very easy to abstract:"}),(0,d.jsx)(o.E,{children:'const Component = () => {\n  const { data, loading, error } = useFetch(async () => fetch("api/data", {}));\n\n  return <div>{!loading ? <div>{data}</div> : null}</div>;\n};'}),(0,d.jsx)(s.P,{children:"Look how tiny and cute this is!"}),(0,d.jsx)(s.P,{children:"The implementation of the fetch hook is very simple:"}),(0,d.jsx)(o.E,{children:"const useFetch = (fetcher) => {\n  const mounted = useRef(true);\n\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    fetcher()\n      .then((data) => {\n        if (mounted.current) {\n          setData(data);\n          setLoading(false);\n        }\n      })\n      .catch((e) => {\n        if (mounted.current) {\n          setError(e);\n          setLoading(false);\n        }\n      });\n\n    return () => {\n      mounted.current = false;\n    };\n  }, []);\n\n  return { data, loading, error };\n};"}),(0,d.jsx)(s.P,{children:"With this we do not need to repeat ourself. All the necessary logic is hidden in the hook. We do not need to think about handling multiple states ourself."}),(0,d.jsx)(s.P,{children:"We can go one step further and pass more options to the hook. For example, we would like to decide, if we fetch on mount of not. And if not, we would like to trigger the fetch call ourself."}),(0,d.jsx)(o.E,{highlight:[{start:29,end:47}],children:"const useFetch = ({ get, onMount = true }) => {\n  const mounted = useRef(true);\n\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    if (!onMount) return;\n    get()\n      .then((data) => {\n        if (mounted.current) {\n          setData(data);\n          setLoading(false);\n        }\n      })\n      .catch((e) => {\n        if (mounted.current) {\n          setError(e);\n          setLoading(false);\n        }\n      });\n\n    return () => {\n      mounted.current = false;\n    };\n  }, []);\n\n  const refetch = useCallback(\n    (...args) => {\n      setLoading(true);\n      get(...args)\n        .then((data) => {\n          if (mounted.current) {\n            setLoading(false);\n            setData(data);\n          }\n        })\n        .catch((e) => {\n          if (mounted.current) {\n            setLoading(false);\n            setError(e);\n          }\n        });\n    },\n    [get]\n  );\n\n  return { data, loading, error, refetch };\n};"}),(0,d.jsx)(s.P,{children:"The main change is the refetch function. We pass all arguments from the refetch to the get function. Effectively we predefine the API getter and invoke it later in time:"}),(0,d.jsx)(o.E,{highlight:[{start:3,end:3},{start:13,end:13}],children:"const Component = () => {\n  const { data, loading, error, refetch } = useFetch({\n    get: async ({ id }) => fetch(`api/users?id=${id}`, {}),\n    onMount: false,\n  });\n\n  return (\n    <div>\n      {!loading ? (\n        <div>\n          <button\n            onClick={() => {\n              refetch({ id: 1 });\n            }}\n          >\n            get user\n          </button>\n        </div>\n      ) : null}\n    </div>\n  );\n};"}),(0,d.jsx)("img",{src:"https://media.giphy.com/media/WrJ8x0niiblWEoo7hE/giphy.gif",alt:""})]})}),(0,d.jsxs)("div",{style:{padding:"3rem 0 1rem 0"},children:[(0,d.jsx)(r.Z.DateCreated,{children:"August 19, 2022"}),(0,d.jsx)(r.Z.Language,{children:"English"}),(0,d.jsx)(r.Z.Organization,{funder:{name:"Stanislav Panchenko"},name:"Stanislav Panchenko",email:"email@stanislavpanchenko.de"}),(0,d.jsx)(r.Z.PartOf,{url:"https://rilexus.github.io/advanced-react-pattern/"}),(0,d.jsx)(r.Z.CopyRight,{name:"Stanislav Panchenko",email:"email@stanislavpanchenko.de"})]})]})})})}},5670:function(n,e,t){(window.__NEXT_P=window.__NEXT_P||[]).push(["/FetchHook",function(){return t(5673)}])}},function(n){n.O(0,[170,113,292,774,888,179],(function(){return e=5670,n(n.s=e);var e}));var e=n.O();_N_E=e}]);