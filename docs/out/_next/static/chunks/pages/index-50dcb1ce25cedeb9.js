(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[5405],{6361:function(e,t,n){"use strict";n.r(t),n.d(t,{default:function(){return d}});var o=n(4359),s=n(5),a=n(6820),i=n(2125),c=(0,i.iv)([""]),r=i.ZP.div.withConfig({displayName:"Title",componentId:"sc-10ps33z-0"})(["",";"],c),l=n(4663),h=n(3236),u=(n(7294),n(5893)),d=function(){return(0,u.jsx)(s.Z,{children:(0,u.jsxs)(a.Z,{children:[(0,u.jsx)("div",{style:{marginRight:"1rem"},children:(0,u.jsx)(o.Z,{})}),(0,u.jsxs)("div",{children:[(0,u.jsx)(r,{as:"h1",children:"Advanced React Patterns"}),(0,u.jsx)(l.P,{children:"I would like to clarify a misconception that a lot of junior to mid level developers have regarding react components. Namely that a react component is not some magic, it is a regular javascript function and can be treated like one."}),(0,u.jsx)(l.P,{children:"The first moment of confusion for me was that one time as I spoke with a junior developer and I have proposed to change this implementation:"}),(0,u.jsx)(h.E,{children:'const Component = () => {\n  const [count, setCount] = useState(10);\n\n  useEffect(() => {\n    if (count === 0) {\n      dispatch({ type: "some-action" });\n    }\n  }, [count]);\n\n  return (\n    <div>\n      <button\n        onClick={() => {\n          setCount((c) => c - 1);\n        }}\n      >\n        Decrement\n      </button>\n    </div>\n  );\n};'}),(0,u.jsx)(l.P,{children:"to this one:"}),(0,u.jsx)(h.E,{children:'const Component = () => {\n  const [count, setCount] = useState(10);\n\n  if (count === 0) {\n    dispatch({ type: "some-action" });\n  }\n  return (\n    <div>\n      <button\n        onClick={() => {\n          setCount((c) => c - 1);\n        }}\n      >\n        Decrement\n      </button>\n    </div>\n  );\n};'}),(0,u.jsx)(l.P,{children:"essentially I have proposed to remove the useEffect from the component."}),(0,u.jsx)(l.P,{children:"At that moment I could sense the confusion of the developer. No! Thats not how it suppose to work. We need the useEffect, so react knows when the counter has changed. He says. But react knows when the counter has changed after you called the setState function. I reply. Yes true, but how does react suppose to know when to call the dispatch function? He says. It does no need to know that. I say. But then the dispatch will not be called ... . He says. We went like this for couple of minutes till I understood that he has a conception of components where he could execute calculations only in hooks like useMemo, useCallback, useEffect and functions defined inside the hook. The execution context of the components function is of limit!"}),(0,u.jsx)(l.P,{children:"To make sure that I understood his misconception correctly, I have asked him to write a component, the user can enter his first name in one input, the last name in another and the component should display the full name."}),(0,u.jsx)(l.P,{children:"This was his solution:"}),(0,u.jsx)(h.E,{children:'const Component = () => {\n  const [firstName, setFirstName] = useState("");\n  const [lastName, setLastName] = useState("");\n  const [fullName, setFullName] = useState("");\n\n  useEffect(() => {\n    setFullName(`${firstName} ${lastName}`);\n  }, [firstName, lastName]);\n\n  return (\n    <div>\n      <div>{fullName}</div>\n      <div>\n        <input\n          type="text"\n          onChange={(e) => setFirstName(e.target.value)}\n          value={firstName}\n        />\n        <input\n          type="text"\n          onChange={(e) => setLastName(e.target.value)}\n          value={lastName}\n        />\n      </div>\n    </div>\n  );\n};'}),(0,u.jsx)("div",{style:{textAlign:"center"},children:(0,u.jsx)("img",{src:"https://media.giphy.com/media/SVgKToBLI6S6DUye1Y/giphy.gif",alt:""})}),(0,u.jsx)(l.P,{children:"I have proposed this solution"}),(0,u.jsx)(h.E,{children:'const Component = () => {\n  const [firstName, setFirstName] = useState("");\n  const [lastName, setLastName] = useState("");\n\n  const fullName = `${firstName} ${lastName}`;\n\n  return (\n    <div>\n      <div>{fullName}</div>\n      <div>\n        <input\n          type="text"\n          onChange={(e) => setFirstName(e.target.value)}\n          value={firstName}\n        />\n        <input\n          type="text"\n          onChange={(e) => setLastName(e.target.value)}\n          value={lastName}\n        />\n      </div>\n    </div>\n  );\n};'}),(0,u.jsx)(l.P,{children:"I could see gears spinning in his head."}),(0,u.jsx)("div",{style:{textAlign:"center"},children:(0,u.jsx)("img",{src:"https://media.giphy.com/media/WRQBXSCnEFJIuxktnw/giphy.gif",alt:""})}),(0,u.jsx)(l.P,{children:'No wonders, the "if statement" did not make any sense to him.'}),(0,u.jsx)(l.P,{children:"I think the confusion results because of the counterintuitive behavior of useState and other react hooks. Just imagine a javascript function will be called again because you call another function within it."}),(0,u.jsx)(l.P,{children:"I would like to provide a mental model to demonstrate that a react component is simply a javascript function."}),(0,u.jsx)(l.P,{children:"First, one needs to understand what happens with the jsx code during the build time. This code:"}),(0,u.jsx)(h.E,{children:'const ComponentA = () => {\n  const [state, setState] = useState(1);\n  console.log("here")\t\t\n  return <div>Some</div>\n}\n\nconst Component = () => {\n  return <ComponentA/>\n}'}),(0,u.jsx)(l.P,{children:"is going to be transpiled to this code:"}),(0,u.jsx)(h.E,{children:'const ComponentA = () => {\n  const [state, setState] = useState(1);\n  console.log("here");\n  return createElement("div", null, "Some");\n};\n\nconst Component = () => {\n  return createElement(ComponentA, null);\n};'}),(0,u.jsx)(l.P,{children:"We can rewrite this code like this:"}),(0,u.jsx)(h.E,{children:'const Component = () => {\n  return createElement(() => {\n    const [state, setState] = useState(1);\n    console.log("here");\n    return createElement("div", null, "Some");\n  }, null);\n};'}),(0,u.jsx)(l.P,{children:"We pass a function"}),(0,u.jsx)(h.E,{children:'() => {\n  const [state, setState] = useState(1);\n  console.log("here");\n  return createElement("div", null, "Some");\n}'}),(0,u.jsx)(l.P,{children:'to the "createElement" function. Essentially saying to react: Please call this function for us. Now everytime we call "setState", react is going to call this function again.'}),(0,u.jsx)(l.P,{children:"Take a look in to the implementation of this component:"}),(0,u.jsx)(h.E,{children:'const Component = () => {\n  const [state, setState] = useState("click me");\n  return (\n    <button\n      onClick={() => {\n        setState("clicked");\n      }}\n    >\n      {state}\n    </button>\n  );\n};\n\nrender(<Component />, document.getElementById("root"));'}),(0,u.jsx)(l.P,{children:"There is nothing unordinary about it, except that the useState is not from react. The implementation of this useState is as follows:"}),(0,u.jsx)(h.E,{children:'let state = null;\nconst useState = (initialState) => {\n  if (state === null) {\n    // set state initially, once\n    state = initialState;\n  }\n  const setState = (newState) => {\n    // set new value to state\n    state = newState;\n    // re-render the Component on every setState call\n    render(<Component />, document.getElementById("root"));\n  };\n\n  // return current state value\n  return [state, setState];\n};'}),(0,u.jsxs)(l.P,{children:["As soon, as we call useState, react re-renders our component. This is not how react implements the useState, for sure. It should help to understand how react calls our component/function again as soon as we set new state and most importantly, that"," ",(0,u.jsx)("b",{children:"we will get the new state on the next call."})," As if we would define all our variables in the global scope."]}),(0,u.jsx)(l.P,{children:'The context, the "space" between the component name and the return statement is ours. We can use its as we like, as if this a normal javascript function.'}),(0,u.jsx)(h.E,{children:'const Component = () => {\n  // our space\n  const [state, setState] = useState(1);\n  // ...\n  // .\n  // . our space\n  // .\n  // ...\n  console.log("here");\n  // ...\n  // .\n  // . our space\n  // .\n  // ...\n  return React.createElement("div", null, "Some");\n};'}),(0,u.jsx)(l.P,{children:"The only rule we have to follow, is that we are not allowed to call hooks conditionally:"}),(0,u.jsx)(h.E,{children:"const Component = () => {\n  const [state, setState] = useState();\n  if(condition){\n    const [otherState, setOther] = useState();\n  }\n  if(condition){\n    useEffect(() => {\n      console.log('here');\n    }, [])\n  }\n  return <div>Some</div>\n};"}),(0,u.jsx)("div",{style:{textAlign:"center"},children:(0,u.jsx)("video",{loop:!0,muted:!0,autoPlay:!0,src:"https://media1.giphy.com/media/RHZtYfdXDL9Wqm5949/giphy360p.mp4?cid=790b761111a6898bf1576add44a3b3122f3591464130d5c2&rid=giphy360p.mp4&ct=v&cc=en"})}),(0,u.jsx)(l.P,{children:'The reason for this is, how react associates every hook with a component. If you call a "setState" function, react needs to know from which component it was called and re-render it.'}),(0,u.jsx)(l.P,{children:"When the component mounts for the first time, react keeps track of how many hooks were called and associates those hooks with the current component. Association of hooks to a component happens on mount and de-association on unmount. If you call a hook conditionally react does not know to which component it belongs. This is a guaranteed bug."})]})]})})}},5557:function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/",function(){return n(6361)}])}},function(e){e.O(0,[939,7952,9774,2888,179],(function(){return t=5557,e(e.s=t);var t}));var t=e.O();_N_E=t}]);